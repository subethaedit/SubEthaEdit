Index: TCMBEEP/TCMBEEPSession.m
===================================================================
--- TCMBEEP/TCMBEEPSession.m	(revision 2960)
+++ TCMBEEP/TCMBEEPSession.m	(revision 2981)
@@ -289,7 +289,7 @@
             sequenceNumber++;
             name = [NSString stringWithFormat:@"%@-p%d-s%d", [[NSCalendarDate date] descriptionWithCalendarFormat:@"%Y-%m-%d--%H-%M-%S.%F-"], [[NSProcessInfo processInfo] processIdentifier], sequenceNumber];
             name = [[origPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:name];
-        } while ([[NSFileManager defaultManager] fileExistsAtPath:logDirectory]);
+        } while ([[NSFileManager defaultManager] fileExistsAtPath:name]);
 
         logDirectory = [name retain];
         [[NSFileManager defaultManager] createDirectoryAtPath:logDirectory attributes:nil];    
Index: NSStringSEEAdditions.m
===================================================================
--- NSStringSEEAdditions.m	(revision 2960)
+++ NSStringSEEAdditions.m	(revision 2981)
@@ -665,7 +665,7 @@
 - (NSString *) stringByReplacingRegularExpressionOperators  {
     static OGRegularExpression *escapingExpression = nil;
     if (!escapingExpression) {
-        escapingExpression = [[OGRegularExpression alloc] initWithString:@"[\\\\(){}\\[\\]?*+^$|]" options:OgreFindNotEmptyOption];
+        escapingExpression = [[OGRegularExpression alloc] initWithString:@"[\\\\\\(\\){}\\[\\]?*+^$|\\-]" options:OgreFindNotEmptyOption];
     }
 	return [escapingExpression replaceAllMatchesInString:self withString:@"\\\\\\0" options:OgreNoneOption];
 }
Index: SyntaxHighlighter.m
===================================================================
--- SyntaxHighlighter.m	(revision 2960)
+++ SyntaxHighlighter.m	(revision 2981)
@@ -135,7 +135,7 @@
 		}
         
         NSRange delimiterRange, stateRange, startRange, nextRange;
-        BOOL foundEnd = NO;
+//        BOOL foundEnd = NO;
         startRange = NSMakeRange(NSNotFound,0);
         // Add start to colorRange to color keywords within
         // But check for starts that contain \n
@@ -152,25 +152,27 @@
             //NSLog(@"Searching for next delimiter");
             delimiterRange = [delimiterMatch rangeOfMatchedString];
             
-            NSRange checkForStartFalsePositiveRange = [theString lineRangeForRange:delimiterRange];
-            if (checkForStartFalsePositiveRange.location>=aRange.location) {
-                OGRegularExpressionMatch * checkMatch;
-                NSEnumerator *checkMatchEnumerator = [[stateDelimiter allMatchesInString:theString range:checkForStartFalsePositiveRange] objectEnumerator];
-                BOOL valid = NO;
-                while ((checkMatch = [checkMatchEnumerator nextObject])) {
-                    if (checkMatch && [delimiterMatch indexOfFirstMatchedSubstring]==[checkMatch indexOfFirstMatchedSubstring]) {
-                        NSRange secondDelimiterRange = [checkMatch rangeOfMatchedString];
-                        if (secondDelimiterRange.location == delimiterRange.location) valid = YES;
-                    }
-
-                }
-                if (!valid) {
-                    currentRange.location++;
-                    currentRange.length--;
-                    continue;
-                }
-                
-            }
+            // FIXME Caret support introduces endless coloring in SoupDump.html
+            
+//            NSRange checkForStartFalsePositiveRange = [theString lineRangeForRange:delimiterRange];
+//            if (checkForStartFalsePositiveRange.location>=aRange.location) {
+//                OGRegularExpressionMatch * checkMatch;
+//                NSEnumerator *checkMatchEnumerator = [[stateDelimiter allMatchesInString:theString range:checkForStartFalsePositiveRange] objectEnumerator];
+//                BOOL valid = NO;
+//                while ((checkMatch = [checkMatchEnumerator nextObject])) {
+//                    if (checkMatch && [delimiterMatch indexOfFirstMatchedSubstring]==[checkMatch indexOfFirstMatchedSubstring]) {
+//                        NSRange secondDelimiterRange = [checkMatch rangeOfMatchedString];
+//                        if (secondDelimiterRange.location == delimiterRange.location) valid = YES;
+//                    }
+//
+//                }
+//                if (!valid) {
+//                    currentRange.location++;
+//                    currentRange.length--;
+//                    continue;
+//                }
+//                
+//            }
                         
             stateRange = NSMakeRange(currentRange.location, NSMaxRange(delimiterRange) - currentRange.location);
 
@@ -289,7 +291,7 @@
         
         [self highlightRegularExpressionsOfAttributedString:aString inRange:colorRange forState:[currentState objectForKey:@"id"]];
         [self highlightPlainStringsOfAttributedString:aString inRange:colorRange forState:[currentState objectForKey:@"id"]];
-
+        
         //NSLog(@"Finished highlighting for this state %@ '%@'", [currentState objectForKey:@"id"], [[aString string] substringWithRange:colorRange]);
 
         currentRange = nextRange;
@@ -333,16 +335,36 @@
     }
 }
 
+// TODO: Get rid of this. See Below.
+
 -(void)highlightPlainStringsOfAttributedString:(NSMutableAttributedString*)aString inRange:(NSRange)aRange forState:(NSString *)aState
 {
-    int aMaxRange = NSMaxRange(aRange);
-    int location;
     NSString *styleID;
     SyntaxDefinition *definition = [self syntaxDefinition];
+    NSString *theString = [aString string];
 
     if (![definition hasTokensForState:aState]) return;
 
+    NSEnumerator *matchEnumerator = [[[definition tokenRegex] allMatchesInString:theString range:aRange] objectEnumerator];
 
+    OGRegularExpressionMatch *aMatch;
+    while ((aMatch = [matchEnumerator nextObject])) {
+        if ((styleID = [definition styleForToken:[aMatch matchedString] inState:aState])) {
+            [aString addAttributes:[theDocument styleAttributesForStyleID:styleID] range:[aMatch rangeOfMatchedString]];
+        }
+    }
+}
+
+-(void)oldHighlightPlainStringsOfAttributedString:(NSMutableAttributedString*)aString inRange:(NSRange)aRange forState:(NSString *)aState
+{
+    int aMaxRange = NSMaxRange(aRange);
+    int location;
+    NSString *styleID;
+    SyntaxDefinition *definition = [self syntaxDefinition];
+    
+    if (![definition hasTokensForState:aState]) return;
+    
+    
     NSScanner *scanner = [NSScanner scannerWithString:[aString string]];
     [scanner setCharactersToBeSkipped:[definition invertedTokenSet]];
     [scanner setScanLocation:aRange.location];
@@ -356,7 +378,7 @@
                     int tokenlength = [token length];
                     NSRange foundRange = NSMakeRange(location-tokenlength,tokenlength);
                     if (NSMaxRange(foundRange)>aMaxRange) break;
-
+                    
                     [aString addAttributes:[theDocument styleAttributesForStyleID:styleID] range:foundRange];
                 }
             }
@@ -365,6 +387,9 @@
     
 }
 
+// TODO: Migrate keywords to one precompiled regex
+// Roll this method back into the highlighter loop to avoid duplicating efforts
+
 -(void)highlightRegularExpressionsOfAttributedString:(NSMutableAttributedString*)aString inRange:(NSRange)aRange forState:(NSString *)aState
 {
     NSArray *regexArray = [[self syntaxDefinition] regularExpressionsInState:aState];    
@@ -441,7 +466,7 @@
 {
     NSRange textRange=NSMakeRange(0,[aTextStorage length]);
     if (textRange.length == 0) return YES; // special case of empty storage
-    double return_after = 0.2;
+    double return_after = 0.20;
     BOOL returnvalue = NO;
     BOOL returncontrol = NO;
     clock_t start_time = clock();
@@ -495,14 +520,14 @@
                 }
 
                 
-                //DEBUGLOG(@"SyntaxHighlighterDomain", AllLogLevel, @"Chunk #%d, Dirty: %@, Chunk: %@", chunks, NSStringFromRange(dirtyRange),NSStringFromRange(chunkRange));
+                //DEBUGLOG(@"SyntaxHighlighterDomain", SimpleLogLevel, @"Chunk #%d, Dirty: %@, Chunk: %@", chunks, NSStringFromRange(dirtyRange),NSStringFromRange(chunkRange));
 
 
                 [self highlightAttributedString:aTextStorage inRange:chunkRange];
                 
                 
                 if ((((double)(clock()-start_time))/CLOCKS_PER_SEC) > return_after) {
-                    DEBUGLOG(@"SyntaxHighlighterDomain", AllLogLevel, @"Coloring took too long, aborting after %f seconds",(((double)(clock()-start_time))/CLOCKS_PER_SEC));
+                    DEBUGLOG(@"SyntaxHighlighterDomain", SimpleLogLevel, @"Coloring took too long, aborting after %f seconds",(((double)(clock()-start_time))/CLOCKS_PER_SEC));
                     returncontrol = YES;
                     break;
                 }
@@ -512,7 +537,7 @@
                     dirtyRange.location = NSMaxRange(chunkRange);
                     dirtyRange.length = lastDirty-dirtyRange.location;
                 } else {
-                    DEBUGLOG(@"SyntaxHighlighterDomain", AllLogLevel, @"Finished coloring of dirtyRange after %f seconds",(((double)(clock()-start_time))/CLOCKS_PER_SEC));
+                    DEBUGLOG(@"SyntaxHighlighterDomain", SimpleLogLevel, @"Finished coloring of dirtyRange after %f seconds",(((double)(clock()-start_time))/CLOCKS_PER_SEC));
                     break;
                 }
             }
@@ -526,7 +551,7 @@
         }
 
         if (returncontrol) {
-            DEBUGLOG(@"SyntaxHighlighterDomain", AllLogLevel, @"Returning control");
+            DEBUGLOG(@"SyntaxHighlighterDomain", SimpleLogLevel, @"Returning control");
             break;
         }
 
Index: NSMutableAttributedStringSEEAdditions.m
===================================================================
--- NSMutableAttributedStringSEEAdditions.m	(revision 2960)
+++ NSMutableAttributedStringSEEAdditions.m	(revision 2981)
@@ -10,11 +10,17 @@
 #ifndef TCM_ISSEED
     #import <OgreKit/OgreKit.h>
 	#import "GeneralPreferences.h"
-	#import "TCMMMUserManager.h"
+	#import "SyntaxHighlighter.h"
 #endif
 
+#ifdef SUBETHAEDIT
+	#import "TCMMMUserManager.h"
+	#import "TCMMMUser.h"
+	#import "TCMMMUserSEEAdditions.h"
 extern NSString * const WrittenByUserIDAttributeName, *ChangedByUserIDAttributeName;
+#endif
 
+
 @implementation NSMutableAttributedString (NSMutableAttributedStringSEEAdditions) 
 
 #ifndef TCM_ISSEED
@@ -348,6 +354,7 @@
     [dictionary setObject:[[[self string] copy] autorelease] forKey:@"String"];
     [dictionary setObject:[NSNumber numberWithUnsignedInt:anEncoding] forKey:@"Encoding"];
     NSMutableDictionary *attributeDictionary=[NSMutableDictionary new];
+#ifdef SUBETHAEDIT
     NSEnumerator *attributeNames=[[NSArray arrayWithObjects:WrittenByUserIDAttributeName,ChangedByUserIDAttributeName,nil] objectEnumerator];
     NSString *attributeName;
     NSRange wholeRange=NSMakeRange(0,[self length]);
@@ -372,6 +379,7 @@
             [attributeArray release];
         }
     }
+#endif
     [dictionary setObject:attributeDictionary forKey:@"Attributes"];
     [attributeDictionary release];
     return dictionary;
@@ -392,6 +400,8 @@
 	if (font && [[[resultDictionary objectForKey:NSFontAttributeName] familyName] isEqualToString:[font familyName]]) [resultDictionary setObject:font forKey:NSFontAttributeName];
 	NSColor *foregroundColor = [attributes objectForKey:NSForegroundColorAttributeName];
 	if (foregroundColor) [resultDictionary setObject:foregroundColor forKey:NSForegroundColorAttributeName];
+	NSNumber *foldingDepth = [attributes objectForKey:kSyntaxHighlightingFoldingDepthAttributeName];
+	if (foldingDepth) [resultDictionary setObject:foldingDepth forKey:kSyntaxHighlightingFoldingDepthAttributeName];
 	
 	return resultDictionary;
 }
@@ -471,6 +481,7 @@
         }
     } while (index<NSMaxRange(aRange));
 
+#ifdef SUBETHAEDIT
     index=aRange.location;
     do {
         NSRange foundRange;
@@ -499,6 +510,7 @@
             [result addAttribute:@"ChangedByUserID" value:author range:foundRange];
         }
     } while (index<NSMaxRange(aRange));
+#endif
     
     return result;
 }
Index: PlainTextEditor.m
===================================================================
--- PlainTextEditor.m	(revision 2960)
+++ PlainTextEditor.m	(revision 2981)
@@ -1319,7 +1319,7 @@
 - (void)updateSelectedSymbol {
     PlainTextDocument *document=[self document];
     if ([[document documentMode] hasSymbols]) {
-        int symbolTag = [document selectedSymbolForRange:[I_textView selectedRange]];
+        int symbolTag = [document selectedSymbolForRange:[(FoldableTextStorage *)[[self document] textStorage] fullRangeForFoldedRange:[I_textView selectedRange]]];
         if (symbolTag == -1) {
             [O_symbolPopUpButton selectItemAtIndex:0];
         } else {
Index: FoldingTextAttachmentCell.m
===================================================================
--- FoldingTextAttachmentCell.m	(revision 2960)
+++ FoldingTextAttachmentCell.m	(revision 2981)
@@ -41,7 +41,7 @@
 
 
 - (BOOL)wantsToTrackMouseForEvent:(NSEvent *)theEvent inRect:(NSRect)cellFrame ofView:(NSView *)controlView atCharacterIndex:(unsigned)charIndex {
-	NSLog(@"%s %@ %@ %@ %d",__FUNCTION__,theEvent, NSStringFromRect(cellFrame), controlView, charIndex);
+//	NSLog(@"%s %@ %@ %@ %d",__FUNCTION__,theEvent, NSStringFromRect(cellFrame), controlView, charIndex);
 	return YES;
 }
 
Index: SyntaxDefinition.h
===================================================================
--- SyntaxDefinition.h	(revision 2960)
+++ SyntaxDefinition.h	(revision 2981)
@@ -33,6 +33,9 @@
 	BOOL I_symbolAndAutocompleteInheritanceReady;
     NSMutableDictionary *I_levelsForStyleIDs;
     SyntaxStyle *I_defaultSyntaxStyle;
+    NSString *I_charsInToken;
+    NSString *I_charsDelimitingToken;
+    OGRegularExpression *I_tokenRegex;
 }
 
 /*"Initizialisation"*/
Index: SyntaxDefinition.m
===================================================================
--- SyntaxDefinition.m	(revision 2960)
+++ SyntaxDefinition.m	(revision 2981)
@@ -74,6 +74,8 @@
 	[I_defaultSyntaxStyle release];
     [I_autocompleteTokenString release];
     [I_levelsForStyleIDs release];
+    [I_charsInToken release];
+    [I_charsDelimitingToken release];
     [self setTokenSet:nil];
     [self setAutoCompleteTokenSet:nil];
     [super dealloc];
@@ -113,15 +115,28 @@
     NSString *charsDelimitingToken = [[[syntaxDefinitionXML nodesForXPath:@"/syntax/head/charsdelimitingtokens" error:&err] lastObject] stringValue];
     NSCharacterSet *tokenSet = nil; // TODO: what should be the value if neither charsInToken nor charsDelimitingToken?
     
+    I_charsInToken = nil;
+    I_charsDelimitingToken = nil;
+    
     if (charsInToken) {
         tokenSet = [NSCharacterSet characterSetWithCharactersInString:charsInToken];
+        I_charsInToken = [charsInToken copy];
     } else if (charsDelimitingToken) {
         tokenSet = [NSCharacterSet characterSetWithCharactersInString:charsDelimitingToken];
         tokenSet = [tokenSet invertedSet];
+        I_charsDelimitingToken = [charsDelimitingToken copy];
     }
     
     [self setTokenSet:tokenSet];
 
+    I_tokenRegex = nil;
+    
+    if (I_charsInToken) {
+        I_tokenRegex = [[OGRegularExpression alloc] initWithString:[NSString stringWithFormat:@"[%@]+",[I_charsInToken stringByReplacingRegularExpressionOperators]] options:OgreFindNotEmptyOption|OgreCaptureGroupOption];
+    } else if (I_charsDelimitingToken) {
+        I_tokenRegex = [[OGRegularExpression alloc] initWithString:[NSString stringWithFormat:@"[^%@]+",[I_charsDelimitingToken stringByReplacingRegularExpressionOperators]] options:OgreFindNotEmptyOption|OgreCaptureGroupOption];
+    }        
+        
     NSString *charsInCompletion = [[[syntaxDefinitionXML nodesForXPath:@"/syntax/head/charsincompletion" error:&err] lastObject] stringValue];
 
 
@@ -269,6 +284,8 @@
         // Add regexes for keyword group
         NSMutableArray *regexes = [NSMutableArray array];
         NSMutableArray *strings = [NSMutableArray array];
+        NSMutableString *combindedRegexRegexString = [NSMutableString stringWithString:@"("];
+        
         [keywordGroupDictionary setObject:regexes forKey:@"RegularExpressions"];
         [keywordGroupDictionary setObject:strings forKey:@"PlainStrings"];
         
@@ -277,9 +294,24 @@
         id regexNode;
         while ((regexNode = [regexEnumerator nextObject])) {
             [regexes addObject:[regexNode stringValue]];
+            [combindedRegexRegexString appendFormat:@"%@|",[regexNode stringValue]];
         }
+        if ([regexNodes count]>0) {
+            [combindedRegexRegexString replaceCharactersInRange:NSMakeRange([combindedRegexRegexString length]-1, 1) withString:@")"];
+            [keywordGroupDictionary setObject:[[[OGRegularExpression alloc] initWithString:combindedRegexRegexString options:OgreFindNotEmptyOption|OgreCaptureGroupOption] autorelease] forKey:@"CompiledRegEx"];            
+        }
+        
+        
+        // Add strings for keyword group
+        NSMutableString *combindedKeywordRegexString = [NSMutableString string];
+        if (I_charsInToken) {
+            [combindedKeywordRegexString appendFormat:@"(?<![%@])(",[I_charsInToken stringByReplacingRegularExpressionOperators]];
+        } else if (I_charsDelimitingToken) {
+            [combindedKeywordRegexString appendFormat:@"(?<=[%@])(",[I_charsDelimitingToken stringByReplacingRegularExpressionOperators]];
+        } else {
+            [combindedKeywordRegexString appendString:@"("]; 
+        }
                 
-        // Add strings for keyword group
         BOOL autocomplete = [[keywordGroupDictionary objectForKey:@"useforautocomplete"] isEqualToString:@"yes"];
         NSMutableArray *autocompleteDictionary = [[self mode] autocompleteDictionary];
         NSArray *stringNodes = [keywordGroupNode nodesForXPath:@"./string" error:&err];
@@ -287,9 +319,20 @@
         id stringNode;
         while ((stringNode = [stringEnumerator nextObject])) {
             [strings addObject:[stringNode stringValue]];
+            [combindedKeywordRegexString appendFormat:@"%@|",[[stringNode stringValue] stringByReplacingRegularExpressionOperators]];
             if (autocomplete) [autocompleteDictionary addObject:[stringNode stringValue]];
         }
-        
+        if ([stringNodes count]>0) {
+            [combindedKeywordRegexString replaceCharactersInRange:NSMakeRange([combindedKeywordRegexString length]-1, 1) withString:@")"];
+            
+            if (I_charsInToken) {
+                [combindedKeywordRegexString appendFormat:@"(?![%@])",[I_charsInToken stringByReplacingRegularExpressionOperators]];
+            } else if (I_charsDelimitingToken) {
+                [combindedKeywordRegexString appendFormat:@"(?=[%@])",[I_charsDelimitingToken stringByReplacingRegularExpressionOperators]];
+            }        
+            
+            [keywordGroupDictionary setObject:[[[OGRegularExpression alloc] initWithString:combindedKeywordRegexString options:OgreFindNotEmptyOption|OgreCaptureGroupOption] autorelease] forKey:@"CompiledKeywords"];
+        }
     }
     
     if ([name isEqualToString:@"default"]) {        
@@ -400,8 +443,8 @@
         
             while ((keywordGroup = [groupEnumerator nextObject])) {
                 NSString *styleID=[keywordGroup objectForKey:kSyntaxHighlightingStyleIDAttributeName];
+                if ([keywordGroup objectForKey:@"CompiledRegEx"]) [newRegExArray addObject:[NSArray arrayWithObjects:[keywordGroup objectForKey:@"CompiledRegEx"], styleID, nil]];
                 
-                // First do the plainstring stuff
                 
                 NSDictionary *keywords;
                 if ((keywords = [keywordGroup objectForKey:@"PlainStrings"])) {
@@ -415,31 +458,41 @@
                         }
                     }
                 }
-                // Then do the regex stuff
                 
-                if ((keywords = [keywordGroup objectForKey:@"RegularExpressions"])) {
-                    NSEnumerator *keywordEnumerator = [keywords objectEnumerator];
-                    NSString *keyword;
-                    NSString *aString;
-                    while ((keyword = [keywordEnumerator nextObject])) {
-                        OGRegularExpression *regex;
-                        unsigned regexOptions = OgreFindNotEmptyOption;
-                        if ((aString = [keywordGroup objectForKey:@"casesensitive"])) {       
-                            if (([aString isEqualTo:@"no"])) {
-                                regexOptions = regexOptions|OgreIgnoreCaseOption;
-                            }
-                        }
-                        if ([OGRegularExpression isValidExpressionString:keyword]) {
-                            if ((regex = [[[OGRegularExpression alloc] initWithString:keyword options:regexOptions] autorelease])) {
-                                [newRegExArray addObject:[NSArray arrayWithObjects:regex, styleID, nil]];
-                            }
-                        } else {
-							[self showWarning:NSLocalizedString(@"Regular Expression Error",@"Regular Expression Error Title") withDescription:[NSString stringWithFormat:NSLocalizedString(@"\"%@\" within state \"%@\" is not a valid regular expression. Please check your regular expression in Find Panel's Ruby mode.",@"Syntax Regular Expression Error Informative Text"),keyword, [keywordGroup objectForKey:@"id"]]];
-                        }
-                    }
-                }
+            
             }
 
+//            groupEnumerator = [keywordGroups objectEnumerator];
+//            while ((keywordGroup = [groupEnumerator nextObject])) {
+//                NSString *styleID=[keywordGroup objectForKey:kSyntaxHighlightingStyleIDAttributeName];
+//                if ([keywordGroup objectForKey:@"CompiledKeywords"]) [newRegExArray addObject:[NSArray arrayWithObjects:[keywordGroup objectForKey:@"CompiledKeywords"], styleID, nil]];
+//            }
+            // First do the plainstring stuff
+//                
+//                // Then do the regex stuff
+//                
+//                if ((keywords = [keywordGroup objectForKey:@"RegularExpressions"])) {
+//                    NSEnumerator *keywordEnumerator = [keywords objectEnumerator];
+//                    NSString *keyword;
+//                    NSString *aString;
+//                    while ((keyword = [keywordEnumerator nextObject])) {
+//                        OGRegularExpression *regex;
+//                        unsigned regexOptions = OgreFindNotEmptyOption;
+//                        if ((aString = [keywordGroup objectForKey:@"casesensitive"])) {       
+//                            if (([aString isEqualTo:@"no"])) {
+//                                regexOptions = regexOptions|OgreIgnoreCaseOption;
+//                            }
+//                        }
+//                        if ([OGRegularExpression isValidExpressionString:keyword]) {
+//                            if ((regex = [[[OGRegularExpression alloc] initWithString:keyword options:regexOptions] autorelease])) {
+//                                [newRegExArray addObject:[NSArray arrayWithObjects:regex, styleID, nil]];
+//                            }
+//                        } else {
+//							[self showWarning:NSLocalizedString(@"Regular Expression Error",@"Regular Expression Error Title") withDescription:[NSString stringWithFormat:NSLocalizedString(@"\"%@\" within state \"%@\" is not a valid regular expression. Please check your regular expression in Find Panel's Ruby mode.",@"Syntax Regular Expression Error Informative Text"),keyword, [keywordGroup objectForKey:@"id"]]];
+//                        }
+//                    }
+//                }
+//
 
         } 
     }
@@ -471,6 +524,11 @@
     return [NSString stringWithFormat:@"SyntaxDefinition, Name:%@ , TokenSet:%@, DefaultState: %@, Uses Spelling Dcitionary: %@", [self name], [self tokenSet], [I_defaultState description], I_useSpellingDictionary?@"Yes.":@"No."];
 }
 
+- (OGRegularExpression *)tokenRegex
+{
+    return I_tokenRegex;
+}
+
 - (NSString *)name
 {
     return I_name;
Index: PlainTextDocument.m
===================================================================
--- PlainTextDocument.m	(revision 2960)
+++ PlainTextDocument.m	(revision 2981)
@@ -154,32 +154,35 @@
 @implementation PlainTextDocument
 
 + (void)initialize {
-    NSFontManager *fontManager=[NSFontManager sharedFontManager];
-    NSMutableDictionary *attributes=[NSMutableDictionary new];
-    NSMutableParagraphStyle *style=[NSMutableParagraphStyle new];
-    [style setLineBreakMode:NSLineBreakByTruncatingTail];
-    [attributes setObject:style forKey:NSParagraphStyleAttributeName];
-    NSFont *font=[NSFont menuFontOfSize:[NSFont systemFontSizeForControlSize:NSSmallControlSize]];
-    NSFont *boldFont      =[fontManager convertFont:font toHaveTrait:NSBoldFontMask];
-    NSFont *italicFont    =[fontManager convertFont:font toHaveTrait:NSItalicFontMask];
-    NSFont *boldItalicFont=[fontManager convertFont:boldFont toHaveTrait:NSItalicFontMask];
-    [attributes setObject:font forKey:NSFontAttributeName];
-    plainSymbolAttributes=[attributes copy];
-
-    [attributes setObject:boldFont forKey:NSFontAttributeName];
-    boldSymbolAttributes=[attributes copy];
-
-    [attributes setObject:italicFont forKey:NSFontAttributeName];
-    if ([italicFont isEqualTo:font]) {
-        [attributes setObject:[NSNumber numberWithFloat:.2] forKey:NSObliquenessAttributeName];
-    }
-    italicSymbolAttributes=[attributes copy];
-
-    [attributes setObject:boldItalicFont forKey:NSFontAttributeName];
-    boldItalicSymbolAttributes=[attributes copy];
-
-    [attributes release];
-    [style release];
+	if (self == [PlainTextDocument class]) {
+		NSFontManager *fontManager=[NSFontManager sharedFontManager];
+		NSMutableDictionary *attributes=[NSMutableDictionary new];
+		NSMutableParagraphStyle *style=[NSMutableParagraphStyle new];
+		[style setLineBreakMode:NSLineBreakByTruncatingTail];
+		[attributes setObject:style forKey:NSParagraphStyleAttributeName];
+		NSFont *font=[NSFont menuFontOfSize:[NSFont systemFontSizeForControlSize:NSSmallControlSize]];
+		NSFont *boldFont      =[fontManager convertFont:font toHaveTrait:NSBoldFontMask];
+		NSFont *italicFont    =[fontManager convertFont:font toHaveTrait:NSItalicFontMask];
+		NSFont *boldItalicFont=[fontManager convertFont:boldFont toHaveTrait:NSItalicFontMask];
+		[attributes setObject:font forKey:NSFontAttributeName];
+		plainSymbolAttributes=[attributes copy];
+	
+		[attributes setObject:boldFont forKey:NSFontAttributeName];
+		boldSymbolAttributes=[attributes copy];
+	
+		[attributes setObject:italicFont forKey:NSFontAttributeName];
+		if ([italicFont isEqualTo:font]) {
+			[attributes setObject:[NSNumber numberWithFloat:.2] forKey:NSObliquenessAttributeName];
+		}
+		italicSymbolAttributes=[attributes copy];
+	
+		[attributes setObject:boldItalicFont forKey:NSFontAttributeName];
+		boldItalicSymbolAttributes=[attributes copy];
+	
+		[attributes release];
+		[style release];
+		
+	}
 }
 
 + (PlainTextDocument *)transientDocument
@@ -288,6 +291,9 @@
     [center addObserver:self selector:@selector(scriptWrapperWillRunScriptNotification:) name:ScriptWrapperWillRunScriptNotification object:nil];
     [center addObserver:self selector:@selector(scriptWrapperDidRunScriptNotification:) name:ScriptWrapperDidRunScriptNotification object:nil];
 
+	[center addObserver:self selector:@selector(documentModeListChanged:) 
+	  name:@"DocumentModeListChanged" object:nil];
+
     I_blockeditTextView=nil;
 
     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(TCM_textStorageLineEndingDidChange:) name:TextStorageLineEndingDidChange object:I_textStorage];
@@ -713,6 +719,7 @@
         NSTextView *textView=[aMenuItem representedObject];
         NSRange wholeRange=NSMakeRange(0,[[self textStorage] length]);
         symbolRange=RangeConfinedToRange(symbolRange,wholeRange);
+        symbolRange=[I_textStorage foldedRangeForFullRange:symbolRange];
         [textView setSelectedRange:symbolRange];
         [textView scrollRangeToVisible:symbolRange];
         if ([textView respondsToSelector:@selector(showFindIndicatorForRange:)]) {
@@ -1228,6 +1235,13 @@
     }
 }
 
+- (void)documentModeListChanged:(NSNotification *)aNotification {
+	DocumentMode *oldMode = [self documentMode];
+	DocumentMode *newMode = [[DocumentModeManager sharedInstance] documentModeForIdentifier:[oldMode documentModeIdentifier]];
+	// just set the document mode - if the object hasn't changed the setter takes care of it
+	[self setDocumentMode:newMode];
+}
+
 - (NSMutableDictionary *)printOptions {
     return I_printOptions;
 }
@@ -4354,6 +4368,7 @@
 
 - (NSRange)rangeOfPrevious:(BOOL)aPrevious symbolForRange:(NSRange)aRange {
     if ([[self documentMode] hasSymbols] && [I_symbolArray count]) {
+    	aRange = [I_textStorage fullRangeForFoldedRange:aRange];
         int position=[self selectedSymbolForRange:aRange];
         if (aPrevious) {
             if (position==-1) return NSMakeRange(NSNotFound,0);
@@ -4364,7 +4379,7 @@
                 while (position-->0) {
                     SymbolTableEntry *entry=[I_symbolArray objectAtIndex:position];
                     if (![entry isSeparator]) {
-                        return [entry jumpRange];
+                        return [I_textStorage foldedRangeForFullRange:[entry jumpRange]];
                     }
                 }
             }
@@ -4375,7 +4390,7 @@
                 if (![entry isSeparator]) {
                     NSRange symbolRange=[[I_symbolArray objectAtIndex:position] jumpRange];
                     if (DisjointRanges(aRange,symbolRange) && NSMaxRange(symbolRange)>NSMaxRange(aRange)) {
-                        return symbolRange;
+                        return [I_textStorage foldedRangeForFullRange:symbolRange];
                     }
                 }
                 position++;
Index: DocumentModeManager.m
===================================================================
--- DocumentModeManager.m	(revision 2960)
+++ DocumentModeManager.m	(revision 2981)
@@ -8,8 +8,6 @@
 
 #import "ModeSettings.h"
 #import "DocumentModeManager.h"
-#import "DocumentController.h"
-#import "PlainTextDocument.h"
 #import "GeneralPreferences.h"
 #import "SyntaxStyle.h"
 #import "SyntaxDefinition.h"
@@ -430,15 +428,6 @@
     [self TCM_findModes];
     [[NSNotificationCenter defaultCenter] postNotificationName:@"DocumentModeListChanged" object:self];
     
-    // replace the DocumentModes in the documents
-    NSEnumerator      *documents = [[[DocumentController sharedDocumentController] documents] objectEnumerator];
-    PlainTextDocument *document = nil;
-    while ((document=[documents nextObject])) {
-        DocumentMode *oldMode = [document documentMode];
-        DocumentMode *newMode = [self documentModeForIdentifier:[oldMode documentModeIdentifier]];
-        [document setDocumentMode:newMode];
-    }
-
     [self setModePrecedenceArray:[self reloadPrecedences]];
     [self revalidatePrecedences];
 }
Index: FullTextStorage.m
===================================================================
--- FullTextStorage.m	(revision 2960)
+++ FullTextStorage.m	(revision 2981)
@@ -391,6 +391,7 @@
 }
 
 - (BOOL)hasMixedLineEndingsInRange:(NSRange)aRange {
+//	NSLog(@"%s %@",__FUNCTION__,NSStringFromRange(aRange));
     static int limit = 0;
     if (limit==0) limit = [[NSUserDefaults standardUserDefaults] integerForKey:@"ByteLengthToUseForModeRecognitionAndEncodingGuessing"];
     if (aRange.length > limit && limit != -1) aRange.length = limit;
@@ -504,21 +505,30 @@
     int length = [string length];
     if (NSMaxRange(returnRange)<length) {
         NSRange nextRange;
-        int rightDepth = [[string attribute:kSyntaxHighlightingFoldingDepthAttributeName atIndex:NSMaxRange(returnRange)+1 longestEffectiveRange:&nextRange inRange:NSMakeRange(NSMaxRange(returnRange), length-NSMaxRange(returnRange))] intValue];
+        int rightDepth = [[string attribute:kSyntaxHighlightingFoldingDepthAttributeName atIndex:NSMaxRange(returnRange) longestEffectiveRange:&nextRange inRange:NSMakeRange(NSMaxRange(returnRange), length-NSMaxRange(returnRange))] intValue];
         while (rightDepth>=depth) {
             returnRange = NSUnionRange(returnRange, nextRange); 
             if (NSMaxRange(returnRange) == length) break;
-            rightDepth = [[string attribute:kSyntaxHighlightingFoldingDepthAttributeName atIndex:NSMaxRange(returnRange)+1 longestEffectiveRange:&nextRange inRange:NSMakeRange(NSMaxRange(returnRange), length-NSMaxRange(returnRange))] intValue];
+            rightDepth = [[string attribute:kSyntaxHighlightingFoldingDepthAttributeName atIndex:NSMaxRange(returnRange) longestEffectiveRange:&nextRange inRange:NSMakeRange(NSMaxRange(returnRange), length-NSMaxRange(returnRange))] intValue];
         }
     }
         
     // Trim start and end
     if (returnRange.location!=NSNotFound) {
+    	NSRange stateStackRange;
         NSRange startRange, endRange;
-        [string attribute:kSyntaxHighlightingStateDelimiterName atIndex:returnRange.location longestEffectiveRange:&startRange inRange:returnRange];
-        [string attribute:kSyntaxHighlightingStateDelimiterName atIndex:NSMaxRange(returnRange)-1 longestEffectiveRange:&endRange inRange:returnRange];        
-        returnRange.location = returnRange.location + startRange.length;
-        returnRange.length = returnRange.length - startRange.length - endRange.length;
+        // get the max state stack range for the end
+        [string attribute:kSyntaxHighlightingStackName 			atIndex:returnRange.location longestEffectiveRange:&stateStackRange inRange:returnRange];
+        [string attribute:kSyntaxHighlightingStateDelimiterName atIndex:returnRange.location longestEffectiveRange:&startRange inRange:stateStackRange];
+
+        // get the max state stack range for the end
+        [string attribute:kSyntaxHighlightingStackName 			atIndex:NSMaxRange(returnRange)-1 longestEffectiveRange:&stateStackRange inRange:returnRange];
+        [string attribute:kSyntaxHighlightingStateDelimiterName atIndex:NSMaxRange(returnRange)-1 longestEffectiveRange:&endRange inRange:stateStackRange];
+        
+        // safety check if end and startrange overlap or touch bail
+        if (NSMaxRange(startRange) >= endRange.location) return NSMakeRange(NSNotFound,0);
+        
+        returnRange = NSMakeRange(NSMaxRange(startRange), endRange.location - NSMaxRange(startRange));
     }
     
     
@@ -558,11 +568,18 @@
     NSString *string = [self string];
     unsigned length = [string length];
     unsigned i;
+    
+    id myUserID = nil;
+    
+#ifdef SUBETHAEDIT
+    myUserID = [TCMMMUserManager myUserID];
+#endif
+    
     for (i = 0; i < length; i++) {
         unichar character = [string characterAtIndex:i];
         NSString *charString = [[NSString alloc] initWithCharactersNoCopy:&character length:1 freeWhenDone:NO];
         if (![charString canBeConvertedToEncoding:encoding]) {
-            [array addObject:[SelectionOperation selectionOperationWithRange:NSMakeRange(i, 1) userID:[TCMMMUserManager myUserID]]];
+            [array addObject:[SelectionOperation selectionOperationWithRange:NSMakeRange(i, 1) userID:myUserID]];
         }
         [charString release];
     }
Index: OgreKit/OgreKit.xcodeproj/project.pbxproj
===================================================================
--- OgreKit/OgreKit.xcodeproj/project.pbxproj	(revision 2960)
+++ OgreKit/OgreKit.xcodeproj/project.pbxproj	(revision 2981)
@@ -638,7 +638,7 @@
 		4DC40E5509150CF30029A2A6 /* OgreKit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreKit.h; path = RegularExpression/OgreKit.h; sourceTree = SOURCE_ROOT; };
 		4DC40E5609150CF30029A2A6 /* OgreKit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreKit.h; path = RegularExpression/OgreKitWithoutFindPanel/OgreKit.h; sourceTree = SOURCE_ROOT; };
 		4DC40E5709150CF30029A2A6 /* OgreKit_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreKit_Prefix.pch; path = RegularExpression/OgreKit_Prefix.pch; sourceTree = SOURCE_ROOT; };
-		4DC40E5809150CF40029A2A6 /* version.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xml; name = version.plist; path = RegularExpression/version.plist; sourceTree = SOURCE_ROOT; };
+		4DC40E5809150CF40029A2A6 /* version.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = version.plist; path = RegularExpression/version.plist; sourceTree = SOURCE_ROOT; };
 		4DC4103F09150D0D0029A2A6 /* OgreTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreTest.h; path = RegularExpressionTest/OgreTest.h; sourceTree = SOURCE_ROOT; };
 		4DC4104009150D0D0029A2A6 /* OgreTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = OgreTest.m; path = RegularExpressionTest/OgreTest.m; sourceTree = SOURCE_ROOT; };
 		4DC4104109150D0E0029A2A6 /* Calc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Calc.h; path = RegularExpressionTest/Calc.h; sourceTree = SOURCE_ROOT; };
@@ -726,7 +726,7 @@
 		4DF530BB0915221700475575 /* ReplaceWithAttributesTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = ReplaceWithAttributesTest.m; path = ReplaceWithAttributesTest/ReplaceWithAttributesTest.m; sourceTree = "<group>"; };
 		4DF530BC0915221700475575 /* ReplaceWithAttributesTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ReplaceWithAttributesTest.h; path = ReplaceWithAttributesTest/ReplaceWithAttributesTest.h; sourceTree = "<group>"; };
 		4DF530BD0915221700475575 /* main.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = main.m; path = ReplaceWithAttributesTest/main.m; sourceTree = "<group>"; };
-		4DF530BE0915221700475575 /* ReplaceWithAttributesTest-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xml; name = "ReplaceWithAttributesTest-Info.plist"; path = "ReplaceWithAttributesTest/ReplaceWithAttributesTest-Info.plist"; sourceTree = "<group>"; };
+		4DF530BE0915221700475575 /* ReplaceWithAttributesTest-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = "ReplaceWithAttributesTest-Info.plist"; path = "ReplaceWithAttributesTest/ReplaceWithAttributesTest-Info.plist"; sourceTree = "<group>"; };
 		4DF530CF0915226200475575 /* English */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.strings; name = English; path = ReplaceWithAttributesTest/English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		4DF530D10915226200475575 /* English */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = English; path = ReplaceWithAttributesTest/English.lproj/MainMenu.nib; sourceTree = "<group>"; };
 		8DC2EF5B0486A6940098B216 /* OgreKit.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = OgreKit.framework; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -2541,11 +2541,11 @@
 				COPY_PHASE_STRIP = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = RegularExpressionTest/OgreTest_Prefix.h;
 				INFOPLIST_FILE = "RegularExpressionTest/OgreTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2576,6 +2576,7 @@
 				COPY_PHASE_STRIP = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = RegularExpressionTest/OgreTest_Prefix.h;
 				GCC_VERSION_i386 = 4.0;
@@ -2584,7 +2585,6 @@
 				INSTALL_PATH = "$(USER_APPS_DIR)";
 				MACOSX_DEPLOYMENT_TARGET_i386 = 10.4;
 				MACOSX_DEPLOYMENT_TARGET_ppc = 10.3;
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2610,11 +2610,11 @@
 			buildSettings = {
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = RegularExpressionTest/OgreTest_Prefix.h;
 				INFOPLIST_FILE = "RegularExpressionTest/OgreTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2641,11 +2641,11 @@
 				COPY_PHASE_STRIP = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = FindPanelTest/OgreFindPanelTest_Prefix.h;
 				INFOPLIST_FILE = "FindPanelTest/FindPanelTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2672,6 +2672,7 @@
 				COPY_PHASE_STRIP = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = FindPanelTest/OgreFindPanelTest_Prefix.h;
 				GCC_VERSION_i386 = 4.0;
@@ -2680,7 +2681,6 @@
 				INSTALL_PATH = "$(USER_APPS_DIR)";
 				MACOSX_DEPLOYMENT_TARGET_i386 = 10.4;
 				MACOSX_DEPLOYMENT_TARGET_ppc = 10.3;
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2702,11 +2702,11 @@
 			buildSettings = {
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = FindPanelTest/OgreFindPanelTest_Prefix.h;
 				INFOPLIST_FILE = "FindPanelTest/FindPanelTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2729,11 +2729,11 @@
 				COPY_PHASE_STRIP = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = MyFindPanelExample/MyFindPanelExample_Prefix.h;
 				INFOPLIST_FILE = "MyFindPanelExample/MyFindPanelExample-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2760,6 +2760,7 @@
 				COPY_PHASE_STRIP = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = MyFindPanelExample/MyFindPanelExample_Prefix.h;
 				GCC_VERSION_i386 = 4.0;
@@ -2768,7 +2769,6 @@
 				INSTALL_PATH = "$(USER_APPS_DIR)";
 				MACOSX_DEPLOYMENT_TARGET_i386 = 10.4;
 				MACOSX_DEPLOYMENT_TARGET_ppc = 10.3;
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2790,11 +2790,11 @@
 			buildSettings = {
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = MyFindPanelExample/MyFindPanelExample_Prefix.h;
 				INFOPLIST_FILE = "MyFindPanelExample/MyFindPanelExample-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2817,11 +2817,11 @@
 				COPY_PHASE_STRIP = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/AppKit.framework/Headers/AppKit.h";
 				INFOPLIST_FILE = "ReplaceWithAttributesTest/ReplaceWithAttributesTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2852,6 +2852,7 @@
 				COPY_PHASE_STRIP = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/AppKit.framework/Headers/AppKit.h";
 				GCC_VERSION_i386 = 4.0;
@@ -2860,7 +2861,6 @@
 				INSTALL_PATH = "$(USER_APPS_DIR)";
 				MACOSX_DEPLOYMENT_TARGET_i386 = 10.4;
 				MACOSX_DEPLOYMENT_TARGET_ppc = 10.3;
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2886,11 +2886,11 @@
 			buildSettings = {
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/AppKit.framework/Headers/AppKit.h";
 				INFOPLIST_FILE = "ReplaceWithAttributesTest/ReplaceWithAttributesTest-Info.plist";
 				INSTALL_PATH = "$(USER_APPS_DIR)";
-				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = (
 					"-framework",
@@ -2916,7 +2916,7 @@
 			buildSettings = {
 				COPY_PHASE_STRIP = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
-				OPTIMIZATION_CFLAGS = "-O0";
+				GCC_OPTIMIZATION_LEVEL = 0;
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = "";
 				OTHER_REZFLAGS = "";
@@ -2935,7 +2935,7 @@
 			buildSettings = {
 				COPY_PHASE_STRIP = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
-				OPTIMIZATION_CFLAGS = "-O0";
+				GCC_OPTIMIZATION_LEVEL = 0;
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = "";
 				OTHER_REZFLAGS = "";
@@ -2952,7 +2952,7 @@
 		4DC412C5091519D50029A2A6 /* Default */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				OPTIMIZATION_CFLAGS = "-O0";
+				GCC_OPTIMIZATION_LEVEL = 0;
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = "";
 				OTHER_REZFLAGS = "";
Index: OgreKit/RegularExpression/OGRegularExpressionPrivate.m
===================================================================
--- OgreKit/RegularExpression/OGRegularExpressionPrivate.m	(revision 2960)
+++ OgreKit/RegularExpression/OGRegularExpressionPrivate.m	(revision 2981)
@@ -48,6 +48,8 @@
 	// \ÇÃë„ë÷ï∂éö
 	[_escapeCharacter release];
 	
+    [_cachedPlainString release];
+    
 	[super dealloc];
 }
 
Index: OgreKit/RegularExpression/OGRegularExpression.h
===================================================================
--- OgreKit/RegularExpression/OGRegularExpression.h	(revision 2960)
+++ OgreKit/RegularExpression/OGRegularExpression.h	(revision 2981)
@@ -91,7 +91,7 @@
 // exception name
 extern NSString	* const OgreException;
 
-@class OGRegularExpressionMatch, OGRegularExpressionEnumerator;
+@class OGRegularExpressionMatch, OGRegularExpressionEnumerator, OGPlainString;
 @protocol OGStringProtocol;
 
 @interface OGRegularExpression : NSObject <NSCopying, NSCoding>
@@ -107,6 +107,9 @@
 	NSMutableArray		*_nameForGroupIndexArray;		// (index-1)„Åßname„ÇíÂºï„ÅèÈÄÜÂºï„ÅçËæûÊõ∏(ÈÖçÂàó)
 														// ÊßãÈÄ†: /(?<a>a+)(?<b>b+)(?<a>c+)/ => ("a", "b", "a")
 	regex_t				*_regexBuffer;					// È¨ºËªäÊ≠£Ë¶èË°®ÁèæÊßãÈÄ†‰Ωì
+    
+    OGPlainString       *_cachedPlainString;
+    int                 _cachedPlainStringHash;
 }
 
 /****************************
Index: OgreKit/RegularExpression/OGRegularExpression.m
===================================================================
--- OgreKit/RegularExpression/OGRegularExpression.m	(revision 2960)
+++ OgreKit/RegularExpression/OGRegularExpression.m	(revision 2981)
@@ -306,7 +306,7 @@
 		_groupIndexForNameDictionary = [[NSMutableDictionary alloc] initWithCapacity:[self numberOfNames]];
 		r = onig_foreach_name(_regexBuffer, namedGroupCallback, _groupIndexForNameDictionary);	// name„ÅÆ‰∏ÄË¶ß„ÇíÂæó„Çã
 		
-		NSEnumerator	*keyEnumerator = [_groupIndexForNameDictionary keyEnumerator];
+		NSEnumerator	*keyEnumerator = [[_groupIndexForNameDictionary allKeys] objectEnumerator];
 		NSString		*name;
 		NSMutableArray	*array;
 		int 			i, maxGroupIndex = 0;
@@ -511,16 +511,35 @@
 		range:NSMakeRange(0, [string length])];
 }
 
+#define TCM_OGPLAINSTRINGCACHE
+
 - (OGRegularExpressionMatch*)matchInString:(NSString*)string 
 	options:(unsigned)options 
 	range:(NSRange)searchRange
 {
 	OGRegularExpressionEnumerator	*enumerator;
+    
+#ifdef TCM_OGPLAINSTRINGCACHE
+    int stringHash = [string hash];
+    if (stringHash != _cachedPlainStringHash) {
+        // FIXME Release on dealloc
+        [_cachedPlainString release];
+        _cachedPlainString = [[OGPlainString stringWithString:string] retain];
+        _cachedPlainStringHash = stringHash;
+    }
 	enumerator = [[OGRegularExpressionEnumerator alloc] 
-		initWithOGString:[(OGPlainString *)[OGPlainString stringWithString:string] substringWithRange:searchRange]
-		options:OgreSearchTimeOptionMask(options)
-		range:searchRange
-		regularExpression:self];
+                  initWithOGString:[(OGPlainString *)_cachedPlainString substringWithRange:searchRange]
+                  options:OgreSearchTimeOptionMask(options)
+                  range:searchRange
+                  regularExpression:self];
+#else
+	enumerator = [[OGRegularExpressionEnumerator alloc] 
+                  initWithOGString:[(OGPlainString *)[OGPlainString stringWithString:string] substringWithRange:searchRange]
+                  options:OgreSearchTimeOptionMask(options)
+                  range:searchRange
+                  regularExpression:self];
+#endif
+    
 	OGRegularExpressionMatch* match=[enumerator nextObject];
 	[enumerator release];
 	return match;
Index: GeneralPreferences.h
===================================================================
--- GeneralPreferences.h	(revision 2960)
+++ GeneralPreferences.h	(revision 2981)
@@ -9,33 +9,8 @@
 #import <Foundation/Foundation.h>
 #import "TCMPreferenceModule.h"
 #import "PCRolloverImageView.h"
+#import "PreferenceKeys.h"
 
-extern NSString * const GeneralViewPreferencesDidChangeNotificiation;
-
-
-extern NSString * const MyColorHuePreferenceKey;
-extern NSString * const CustomMyColorHuePreferenceKey;
-extern NSString * const SelectionSaturationPreferenceKey;
-extern NSString * const ChangesSaturationPreferenceKey;
-extern NSString * const HighlightChangesPreferenceKey;
-extern NSString * const HighlightChangesAlonePreferenceKey;
-extern NSString * const OpenDocumentOnStartPreferenceKey;
-extern NSString * const SelectedMyColorPreferenceKey;
-extern NSString * const ModeForNewDocumentsPreferenceKey;
-extern NSString * const AdditionalShownPathComponentsPreferenceKey;
-extern NSString * const MyNamePreferenceKey;
-extern NSString * const MyAIMPreferenceKey ;
-extern NSString * const MyEmailPreferenceKey;
-extern NSString * const MyImagePreferenceKey;
-extern NSString * const MyAIMIdentifierPreferenceKey;
-extern NSString * const MyEmailIdentifierPreferenceKey;
-extern NSString * const MyNamesPreferenceKey;
-extern NSString * const MyAIMsPreferenceKey;
-extern NSString * const MyEmailsPreferenceKey;
-extern NSString * const SynthesiseFontsPreferenceKey;
-extern NSString * const OpenNewDocumentInTabKey;
-extern NSString * const AlwaysShowTabBarKey;
-
 @class DocumentModePopUpButton;
 
 @interface GeneralPreferences : TCMPreferenceModule {
Index: GeneralPreferences.m
===================================================================
--- GeneralPreferences.m	(revision 2960)
+++ GeneralPreferences.m	(revision 2981)
@@ -14,32 +14,6 @@
 #import "AppController.h"
 #import <AddressBook/AddressBook.h>
 
-NSString * const GeneralViewPreferencesDidChangeNotificiation =
-               @"GeneralViewPreferencesDidChangeNotificiation";
-
-NSString * const MyColorHuePreferenceKey                    = @"MyColorHue";
-NSString * const CustomMyColorHuePreferenceKey              = @"CustomMyColorHue";
-NSString * const SelectionSaturationPreferenceKey           = @"MySelectionSaturation";
-NSString * const ChangesSaturationPreferenceKey             = @"MyChangesSaturation";
-NSString * const HighlightChangesPreferenceKey              = @"HighlightChanges";
-NSString * const HighlightChangesAlonePreferenceKey         = @"HighlightChangesAlone";
-NSString * const OpenDocumentOnStartPreferenceKey           = @"OpenDocumentOnStart";
-NSString * const ModeForNewDocumentsPreferenceKey           = @"ModeForNewDocuments";
-NSString * const AdditionalShownPathComponentsPreferenceKey = @"AdditionalShownPathComponents";
-NSString * const SelectedMyColorPreferenceKey               = @"SelectedMyColor";
-NSString * const MyNamePreferenceKey                        = @"MyName";
-NSString * const MyAIMPreferenceKey                         = @"MyAIM";
-NSString * const MyEmailPreferenceKey                       = @"MyEmail";
-NSString * const MyImagePreferenceKey                       = @"MyImage";
-NSString * const MyAIMIdentifierPreferenceKey               = @"MyAIMIdentifier";
-NSString * const MyEmailIdentifierPreferenceKey             = @"MyEmailIdentifier";
-NSString * const MyAIMsPreferenceKey                        = @"MyAIMs";
-NSString * const MyEmailsPreferenceKey                      = @"MyEmails";
-NSString * const SynthesiseFontsPreferenceKey               = @"SynthesiseFonts";
-NSString * const OpenNewDocumentInTabKey                    = @"OpenNewDocumentInTab";
-NSString * const AlwaysShowTabBarKey                        = @"AlwaysShowTabBar";
-
-
 @implementation GeneralPreferences
 
 + (void)initialize {
Index: PreferenceKeys.h
===================================================================
--- PreferenceKeys.h	(revision 0)
+++ PreferenceKeys.h	(revision 2981)
@@ -0,0 +1,36 @@
+//
+//  PreferenceKeys.h
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+
+
+extern NSString * const GeneralViewPreferencesDidChangeNotificiation;
+
+
+extern NSString * const MyColorHuePreferenceKey;
+extern NSString * const CustomMyColorHuePreferenceKey;
+extern NSString * const SelectionSaturationPreferenceKey;
+extern NSString * const ChangesSaturationPreferenceKey;
+extern NSString * const HighlightChangesPreferenceKey;
+extern NSString * const HighlightChangesAlonePreferenceKey;
+extern NSString * const OpenDocumentOnStartPreferenceKey;
+extern NSString * const SelectedMyColorPreferenceKey;
+extern NSString * const ModeForNewDocumentsPreferenceKey;
+extern NSString * const AdditionalShownPathComponentsPreferenceKey;
+extern NSString * const MyNamePreferenceKey;
+extern NSString * const MyAIMPreferenceKey ;
+extern NSString * const MyEmailPreferenceKey;
+extern NSString * const MyImagePreferenceKey;
+extern NSString * const MyAIMIdentifierPreferenceKey;
+extern NSString * const MyEmailIdentifierPreferenceKey;
+extern NSString * const MyNamesPreferenceKey;
+extern NSString * const MyAIMsPreferenceKey;
+extern NSString * const MyEmailsPreferenceKey;
+extern NSString * const SynthesiseFontsPreferenceKey;
+extern NSString * const OpenNewDocumentInTabKey;
+extern NSString * const AlwaysShowTabBarKey;
Index: PreferenceKeys.m
===================================================================
--- PreferenceKeys.m	(revision 0)
+++ PreferenceKeys.m	(revision 2981)
@@ -0,0 +1,34 @@
+//
+//  PreferenceKeys.m
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import "PreferenceKeys.h"
+
+NSString * const GeneralViewPreferencesDidChangeNotificiation =
+               @"GeneralViewPreferencesDidChangeNotificiation";
+
+NSString * const MyColorHuePreferenceKey                    = @"MyColorHue";
+NSString * const CustomMyColorHuePreferenceKey              = @"CustomMyColorHue";
+NSString * const SelectionSaturationPreferenceKey           = @"MySelectionSaturation";
+NSString * const ChangesSaturationPreferenceKey             = @"MyChangesSaturation";
+NSString * const HighlightChangesPreferenceKey              = @"HighlightChanges";
+NSString * const HighlightChangesAlonePreferenceKey         = @"HighlightChangesAlone";
+NSString * const OpenDocumentOnStartPreferenceKey           = @"OpenDocumentOnStart";
+NSString * const ModeForNewDocumentsPreferenceKey           = @"ModeForNewDocuments";
+NSString * const AdditionalShownPathComponentsPreferenceKey = @"AdditionalShownPathComponents";
+NSString * const SelectedMyColorPreferenceKey               = @"SelectedMyColor";
+NSString * const MyNamePreferenceKey                        = @"MyName";
+NSString * const MyAIMPreferenceKey                         = @"MyAIM";
+NSString * const MyEmailPreferenceKey                       = @"MyEmail";
+NSString * const MyImagePreferenceKey                       = @"MyImage";
+NSString * const MyAIMIdentifierPreferenceKey               = @"MyAIMIdentifier";
+NSString * const MyEmailIdentifierPreferenceKey             = @"MyEmailIdentifier";
+NSString * const MyAIMsPreferenceKey                        = @"MyAIMs";
+NSString * const MyEmailsPreferenceKey                      = @"MyEmails";
+NSString * const SynthesiseFontsPreferenceKey               = @"SynthesiseFonts";
+NSString * const OpenNewDocumentInTabKey                    = @"OpenNewDocumentInTab";
+NSString * const AlwaysShowTabBarKey                        = @"AlwaysShowTabBar";
Index: GutterRulerView.m
===================================================================
--- GutterRulerView.m	(revision 2960)
+++ GutterRulerView.m	(revision 2981)
@@ -10,10 +10,30 @@
 #import "SyntaxHighlighter.h"
 #import "FoldableTextStorage.h"
 
-#define FOLDING_BAR_WIDTH 9.
+#define FOLDING_BAR_WIDTH 10.
 #define RIGHT_INSET  4.
-#define MAX_FOLDING_DEPTH 12.
+#define MAX_FOLDING_DEPTH 10.
+#define COLOR_FOR_DEPTH(depth) [NSColor colorWithCalibratedWhite:MAX(1.0 - ((MAX((depth), 0.0) - 0) / MAX_FOLDING_DEPTH), 0.2) alpha:1.0]
 
+FOUNDATION_STATIC_INLINE void DrawIndicatorForDepthInRect(int aDepth, NSRect aRect) {
+	[COLOR_FOR_DEPTH(aDepth) set];
+	NSRectFill(aRect); 
+
+// a try with steps
+//	[[NSColor whiteColor] set]; 
+//	NSRectFill(aRect); 
+//	NSRect depthInsetRect = aRect;
+//	int stripeWidth = 2;
+//	depthInsetRect.size.width = stripeWidth;
+//	int depth = MAX(1, aDepth - floor(aRect.size.width / stripeWidth));
+//	for (; depth <= aDepth; depth++) {
+//		[COLOR_FOR_DEPTH(depth) set];
+//		NSRectFill(depthInsetRect);
+//		depthInsetRect.origin.x += depthInsetRect.size.width;
+//	}
+}
+
+
 @interface NSBezierPath (BezierPathGutterRulerViewAdditions)
 + (void)fillTriangleInRect:(NSRect)aRect arrowPoint:(NSRectEdge)anEdge;
 @end
@@ -45,11 +65,6 @@
     [super drawRect:aRect];
 }
 
-- (NSColor *)colorForLineNumber:(int)aLineNumber inTextStorage:(FoldableTextStorage *)aTextStorage {
-	int foldingDepth = [aTextStorage foldingDepthForLine:aLineNumber];
-	return [NSColor colorWithCalibratedWhite:1.0 - ((MAX(foldingDepth, 0.0) - 0) / MAX_FOLDING_DEPTH) alpha:1.0];
-}
-
 - (NSRect)baseRectForFoldingBar {
 	double ruleThickness = [self ruleThickness];
 	double rightHandAlignment = ruleThickness - FOLDING_BAR_WIDTH - RIGHT_INSET;
@@ -141,9 +156,8 @@
 		foldingAreaRect.origin.y = boundingRect.origin.y - visibleRect.origin.y;
         foldingAreaRect.size.height = NSMaxY(lineFragmentRectForLastCharacter) - boundingRect.origin.y;
        	
-       	NSColor *depthColor = [self colorForLineNumber:lineNumber inTextStorage:textStorage];
-		[depthColor set];
-        NSRectFill(foldingAreaRect);
+       	int foldingDepth = [textStorage foldingDepthForLine:lineNumber];
+       	DrawIndicatorForDepthInRect(foldingDepth, foldingAreaRect);
 
 		if (lineRange.length) {
 			[textStorage attribute:NSAttachmentAttributeName atIndex:lineRange.location longestEffectiveRange:&longestEffectiveAttachmentRange inRange:lineRange];
@@ -202,10 +216,12 @@
 			foldingAreaRect.size.height = NSMaxY(lineFragmentRectForLastCharacter) - boundingRect.origin.y;
 
 			if (lineRange.length > 0) {
-				depthColor = [self colorForLineNumber:lineNumber inTextStorage:textStorage];;
+				foldingDepth = [textStorage foldingDepthForLine:lineNumber];
+		       	DrawIndicatorForDepthInRect(foldingDepth, foldingAreaRect);
+			} else {
+				[[NSColor whiteColor] set];
+				NSRectFill(foldingAreaRect);
 			}
-			[depthColor set];
-			NSRectFill(foldingAreaRect);
 
 			if (lineRange.length) {
 				[textStorage attribute:NSAttachmentAttributeName atIndex:lineRange.location longestEffectiveRange:&longestEffectiveAttachmentRange inRange:lineRange];
@@ -285,19 +301,25 @@
 			unsigned lineNumber=[textStorage lineNumberForLocation:lineRange.location];
 			if ([textStorage foldingDepthForLine:lineNumber] > 0) {
 				NSRange foldingRange = [textStorage foldingRangeForLine:lineNumber];
-				if ([anEvent clickCount] == 1) {
-					// show
-//					if ([textView respondsToSelector:@selector(showFindIndicatorForRange:)]) {
-//						[textView showFindIndicatorForRange:foldingRange];
-//					} else {
-						[textView setSelectedRange:foldingRange];
-//					}
-				} else if ([anEvent clickCount] == 2) {
-					// fold
-					[textStorage foldRange:foldingRange];
+				if (foldingRange.location != NSNotFound) {
+					if ([anEvent clickCount] == 1) {
+						// show
+	//					if ([textView respondsToSelector:@selector(showFindIndicatorForRange:)]) {
+	//						[textView showFindIndicatorForRange:foldingRange];
+	//					} else {
+							[textView setSelectedRange:foldingRange];
+	//					}
+					} else if ([anEvent clickCount] == 2) {
+						// fold
+						[textStorage foldRange:foldingRange];
+					}
 				}
 			}
 		}
+
+		// always clear the mousedown point
+		I_lastMouseDownPoint = NSZeroPoint;
+		[self setNeedsDisplay:YES];
 	} else {
 		// else call super so the delegate can handle
 		[super mouseDown:anEvent];
Index: ScriptWrapper.m
===================================================================
--- ScriptWrapper.m	(revision 2960)
+++ ScriptWrapper.m	(revision 2981)
@@ -6,12 +6,16 @@
 //  Copyright 2006 TheCodingMonkeys. All rights reserved.
 //
 
+#import <Carbon/Carbon.h>
 #import "ScriptWrapper.h"
 #import "NSAppleScriptTCMAdditions.h"
-#import "AppController.h"
 #import "SESendProc.h"
 #import "SEActiveProc.h"
 
+#ifdef SUBETHAEDIT
+	#import "AppController.h"
+#endif
+
 NSString * const ScriptWrapperDisplayNameSettingsKey     =@"displayname";
 NSString * const ScriptWrapperShortDisplayNameSettingsKey=@"shortdisplayname";
 NSString * const ScriptWrapperToolbarToolTipSettingsKey  =@"toolbartooltip";
@@ -176,9 +180,11 @@
     [[NSNotificationCenter defaultCenter] postNotificationName:ScriptWrapperWillRunScriptNotification object:self];
     NSDictionary *errorDictionary=nil;
     [self executeAndReturnError:&errorDictionary];
+#ifdef SUBETHAEDIT
     if (errorDictionary) {
         [[AppController sharedInstance] reportAppleScriptError:errorDictionary];
     }
+#endif
     [[NSNotificationCenter defaultCenter] postNotificationName:ScriptWrapperDidRunScriptNotification object:self userInfo:errorDictionary];
 }
 
Index: FoldableTextStorage.h
===================================================================
--- FoldableTextStorage.h	(revision 2960)
+++ FoldableTextStorage.h	(revision 2981)
@@ -123,6 +123,9 @@
 
 @end
 
+
+#ifdef SUBETHAEDIT
+
 #pragma mark -
 
 @interface FoldableTextStorage (TextStorageScriptingAdditions)
@@ -142,3 +145,4 @@
 
 @end
 
+#endif
\ No newline at end of file
Index: FoldableTextStorage.m
===================================================================
--- FoldableTextStorage.m	(revision 2960)
+++ FoldableTextStorage.m	(revision 2981)
@@ -12,16 +12,17 @@
 #import "SyntaxHighlighter.h"
 #import "EncodingManager.h"
 #import "PlainTextDocument.h"
-#import "PlainTextWindowController.h"
 #import "TCMMMUserManager.h"
 #import "SelectionOperation.h"
 #import "TCMMMUserSEEAdditions.h"
 #import "GeneralPreferences.h"
-#import "ScriptTextSelection.h"
-#import "ScriptLine.h"
-#import "ScriptCharacters.h"
 #import "DocumentMode.h"
 
+#ifdef SUBETHAEDIT
+	#import "ScriptTextSelection.h"
+	#import "ScriptLine.h"
+	#import "ScriptCharacters.h"
+#endif
 
 static NSArray *S_nonSyncAttributes = nil;
 
@@ -905,8 +906,8 @@
 	}
 
 	NSRange foldingRange = [self fullRangeForFoldedRange:attributeRange];
-	
 	foldingRange = [I_fullTextStorage foldableRangeForCharacterAtIndex:foldingRange.location];
+	if (foldingRange.location == NSNotFound) return foldingRange;
 	foldingRange = [self foldedRangeForFullRange:foldingRange];
 //	NSLog(@"%s line:%d attributeRange:%@ foldingRange:%@",__FUNCTION__,aLineNumber, NSStringFromRange(attributeRange), NSStringFromRange(foldingRange));
 
@@ -1064,6 +1065,8 @@
 
 @end
 
+#ifdef SUBETHAEDIT
+
 #pragma mark -
 
 @implementation FoldableTextStorage (TextStorageScriptingAdditions)
@@ -1208,3 +1211,4 @@
 
 @end
 
+#endif
\ No newline at end of file
Index: Modes/Objective-C.mode/Contents/Resources/SyntaxDefinition.xml
===================================================================
--- Modes/Objective-C.mode/Contents/Resources/SyntaxDefinition.xml	(revision 2960)
+++ Modes/Objective-C.mode/Contents/Resources/SyntaxDefinition.xml	(revision 2981)
@@ -22,7 +22,7 @@
             <state-link mode="C" state="SingleComment"/>
             <state-link mode="C" state="String"/>
 
-            <state id="NSString" type="string" color="#760f15" font-weight="normal" font-style="normal" foldable="yes">
+            <state id="NSString" type="string" color="#760f15" font-weight="normal" font-style="normal" foldable="no">
                 <begin><string>@"</string></begin>
                 <end><regex>(((?&lt;!\\)(\\\\)*)|^)"</regex></end>
             </state>
@@ -30,12 +30,24 @@
             <state id="Block" color="#000" background-color="#fff" font-weight="normal" font-style="normal" type="block" foldable="yes">
                 <begin><regex>{</regex></begin>
                 <end><regex>}</regex></end>
+                <import mode="C" keywords-only="yes" />
                 <import mode="Objective-C" />
             </state>
 
-            <state id="Message" color="#000" background-color="#fff" font-weight="normal" font-style="normal" type="block" foldable="yes">
+            <state id="Objective-C-@-clauses" color="#000" background-color="#fff" font-weight="normal" font-style="normal" type="block" foldable="yes">
+                <begin><regex>(?:@implementation|@interface|@protocol)\s+[\w_]+(?:\s*(?:(?:\(\s*[\w_]+\s*\))|:\s*[\w_]+\s*))?</regex></begin>
+                <end><regex>@end</regex></end>
+                <!-- needs to be done again because a bug in import -->
+                <import mode="C" keywords-only="yes" />
+                <import mode="Objective-C" />
+            </state>
+
+
+            <!-- does influence folding indication in a imho negative way when editing (dom) (also is very perfomance intensive as it turns out
+            <state id="Message" color="#000" background-color="#fff" font-weight="normal" font-style="normal" type="block" foldable="no">
                 <begin><regex>\[</regex></begin>
                 <end><regex>\]</regex></end>
+                <import mode="C" keywords-only="yes" />
                 <import mode="Objective-C" />
                 <keywords id="In Messages" color="#6C0540" casesensitive="yes">
                     <regex>[^:]\([^)]*\)\s*([A-Za-z0-9_]+)\s*[{;]</regex>
@@ -44,6 +56,7 @@
                     <regex>(?&lt;![:\s])\s+([A-Za-z0-9_]+)]</regex>
                 </keywords>
             </state>
+            -->
 
             <keywords id="Methods" color="#6C0540" casesensitive="yes">
                 <regex>[^:]\([^)]*\)\s*([A-Za-z0-9_]+)\s*[{;]</regex>
Index: DocumentMode.m
===================================================================
--- DocumentMode.m	(revision 2960)
+++ DocumentMode.m	(revision 2981)
@@ -17,10 +17,13 @@
 #import "RegexSymbolParser.h"
 #import "RegexSymbolDefinition.h"
 #import "NSMenuTCMAdditions.h"
-#import "AppController.h"
+#import <Carbon/Carbon.h>
 #import "ScriptWrapper.h"
-#import <Carbon/Carbon.h>
 
+#ifdef SUBETHAEDIT
+	#import "AppController.h"
+#endif
+
 NSString * const DocumentModeShowTopStatusBarPreferenceKey     = @"ShowBottomStatusBar";
 NSString * const DocumentModeShowBottomStatusBarPreferenceKey  = @"ShowTopStatusBar";
 NSString * const DocumentModeEncodingPreferenceKey             = @"Encoding";
@@ -167,7 +170,11 @@
         
         // Sort the autocomplete dictionary
         [[self autocompleteDictionary] sortUsingSelector:@selector(caseInsensitiveCompare:)];
+
+        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
         
+#ifdef SUBETHAEDIT
+        
         // Load scripts
         I_scriptsByFilename = [NSMutableDictionary new];
         NSString *scriptFolder = [[aBundle resourcePath] stringByAppendingPathComponent:@"Scripts"];
@@ -226,7 +233,6 @@
         }
 
         // ToolbarHandling
-        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
         NSString *toolbarDefaultKey=[NSString stringWithFormat:@"NSToolbar Configuration %@",[self documentModeIdentifier]];
         if (![defaults objectForKey:toolbarDefaultKey]) {
             NSDictionary *oldDefaultToolbar=[defaults objectForKey:@"NSToolbar Configuration " BASEMODEIDENTIFIER];
@@ -254,10 +260,11 @@
                 [defaults setObject:newModeToolbar forKey:toolbarDefaultKey];
             }
         }
+#endif
         
         // Preference Handling
         [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:NSApplicationWillTerminateNotification object:nil];
-        NSMutableDictionary *dictionary=[[[[NSUserDefaults standardUserDefaults] objectForKey:[self documentModeIdentifier]] mutableCopy] autorelease];
+        NSMutableDictionary *dictionary=[[[defaults objectForKey:[self documentModeIdentifier]] mutableCopy] autorelease];
         if (dictionary) {
             // color is deprecated since 2.1 - so ignore it
             [self setDefaults:dictionary];
Index: SubEthaEdit.xcodeproj/project.pbxproj
===================================================================
--- SubEthaEdit.xcodeproj/project.pbxproj	(revision 2960)
+++ SubEthaEdit.xcodeproj/project.pbxproj	(revision 2981)
@@ -368,6 +368,8 @@
 		F20948EE0C7B4C7100E78EBA /* UserStatisticsController.m in Sources */ = {isa = PBXBuildFile; fileRef = F20948EB0C7B4C7100E78EBA /* UserStatisticsController.m */; };
 		F209A3C30CB6999700C8A744 /* ConnectionBrowser.nib in Resources */ = {isa = PBXBuildFile; fileRef = F2D12A090BF0B6B000A776CC /* ConnectionBrowser.nib */; };
 		F20E1FAE0CACFC75005DEAF5 /* ThousandSeparatorValueTransformer.m in Sources */ = {isa = PBXBuildFile; fileRef = F20E1FAC0CACFC75005DEAF5 /* ThousandSeparatorValueTransformer.m */; };
+		F212908B0F8EC56F0076B6B1 /* NSDictionaryTCMAdditions.m in Sources */ = {isa = PBXBuildFile; fileRef = 142891240957457500D14688 /* NSDictionaryTCMAdditions.m */; };
+		F21290980F8EC5870076B6B1 /* NSMutableAttributedStringSEEAdditions.m in Sources */ = {isa = PBXBuildFile; fileRef = 142D18B30BAEDBBE00B9EF1C /* NSMutableAttributedStringSEEAdditions.m */; };
 		F2230A490BE0243100437D55 /* TCMBEEPBencodedMessage.m in Sources */ = {isa = PBXBuildFile; fileRef = F2230A460BE0243100437D55 /* TCMBEEPBencodedMessage.m */; };
 		F2230A4A0BE0243100437D55 /* TCMBEEPBencodingProfile.m in Sources */ = {isa = PBXBuildFile; fileRef = F2230A480BE0243100437D55 /* TCMBEEPBencodingProfile.m */; };
 		F2280A3F0BEF621700255AAE /* SDDirectoryUserGroupList.m in Sources */ = {isa = PBXBuildFile; fileRef = F2280A300BEF56AB00255AAE /* SDDirectoryUserGroupList.m */; };
@@ -459,7 +461,41 @@
 		F2D5FF4D0CB2679100407399 /* PrintPrefs.icns in Resources */ = {isa = PBXBuildFile; fileRef = F2D5FF4C0CB2679100407399 /* PrintPrefs.icns */; };
 		F2D5FF510CB26EA800407399 /* ToolbarIconRunInTerminal.icns in Resources */ = {isa = PBXBuildFile; fileRef = F2D5FF4F0CB26EA800407399 /* ToolbarIconRunInTerminal.icns */; };
 		F2D5FF520CB26EA800407399 /* ToolbarIconTerminal.icns in Resources */ = {isa = PBXBuildFile; fileRef = F2D5FF500CB26EA800407399 /* ToolbarIconTerminal.icns */; };
+		F2D86C2E0F8E7EFA00B912A2 /* SEPAppController.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86C2D0F8E7EFA00B912A2 /* SEPAppController.m */; };
+		F2D86C300F8E7F6A00B912A2 /* SEPMainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = F2D86C2F0F8E7F6A00B912A2 /* SEPMainMenu.xib */; };
+		F2D86C3D0F8E7FFB00B912A2 /* UniversalDetector.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F2A093BB0C9EBB42000AD27A /* UniversalDetector.framework */; };
+		F2D86C3E0F8E801400B912A2 /* OgreKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 144E3AA40B6FEE8D001C49C2 /* OgreKit.framework */; };
+		F2D86C510F8E811600B912A2 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86C500F8E811600B912A2 /* main.m */; };
+		F2D86C7F0F8E849800B912A2 /* SEPLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86C7E0F8E849800B912A2 /* SEPLogger.m */; };
+		F2D86C9F0F8E88EB00B912A2 /* SyntaxStyle.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893C40957594500D14688 /* SyntaxStyle.m */; };
+		F2D86CA00F8E88EC00B912A2 /* SyntaxHighlighter.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893C20957594500D14688 /* SyntaxHighlighter.m */; };
+		F2D86CA10F8E88ED00B912A2 /* SyntaxDefinition.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893C00957594500D14688 /* SyntaxDefinition.m */; };
+		F2D86CB90F8E8A0F00B912A2 /* DocumentModeManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893B80957594500D14688 /* DocumentModeManager.m */; };
+		F2D86CBA0F8E8A1400B912A2 /* DocumentMode.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893B60957594500D14688 /* DocumentMode.m */; };
+		F2D86CBF0F8E8A2E00B912A2 /* ScriptWrapper.m in Sources */ = {isa = PBXBuildFile; fileRef = 5EA1258809E2B4190055965D /* ScriptWrapper.m */; };
+		F2D86CC30F8E8A5200B912A2 /* EncodingManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893E109575A3000D14688 /* EncodingManager.m */; };
+		F2D86CC60F8E8A5B00B912A2 /* RegexSymbolParser.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893BC0957594500D14688 /* RegexSymbolParser.m */; };
+		F2D86CC70F8E8A5C00B912A2 /* RegexSymbolDefinition.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893BA0957594500D14688 /* RegexSymbolDefinition.m */; };
+		F2D86CCF0F8E8A7A00B912A2 /* SymbolTableEntry.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893BE0957594500D14688 /* SymbolTableEntry.m */; };
+		F2D86CD40F8E8ABD00B912A2 /* NSColorTCMAdditions.m in Sources */ = {isa = PBXBuildFile; fileRef = 14289207095751CB00D14688 /* NSColorTCMAdditions.m */; };
+		F2D86CDC0F8E8B2600B912A2 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 14288FDF09573EA300D14688 /* Carbon.framework */; };
+		F2D86DA40F8E8B3E00B912A2 /* ModeSettings.m in Sources */ = {isa = PBXBuildFile; fileRef = 311717F20A0E8C3600A9DA18 /* ModeSettings.m */; };
+		F2D86DAA0F8E8B6000B912A2 /* SelectionOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893AC095758FD00D14688 /* SelectionOperation.m */; };
+		F2D86DAD0F8E8B6600B912A2 /* TextOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 142893AE095758FD00D14688 /* TextOperation.m */; };
+		F2D86DB20F8E8B7F00B912A2 /* TCMMMOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 1428931A095756D800D14688 /* TCMMMOperation.m */; };
+		F2D86DBA0F8E9B9A00B912A2 /* PreferenceKeys.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86DB90F8E9B9A00B912A2 /* PreferenceKeys.m */; };
+		F2D86DDD0F8E9CF500B912A2 /* CFTreeTCMAdditions.m in Sources */ = {isa = PBXBuildFile; fileRef = 1428911D0957457500D14688 /* CFTreeTCMAdditions.m */; };
+		F2D86E1B0F8EA5DC00B912A2 /* PreferenceKeys.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86DB90F8E9B9A00B912A2 /* PreferenceKeys.m */; };
+		F2D86E5B0F8EB44100B912A2 /* Modes in Resources */ = {isa = PBXBuildFile; fileRef = 1428904A0957427100D14688 /* Modes */; };
+		F2D86E7B0F8EB57000B912A2 /* TestFiles in Resources */ = {isa = PBXBuildFile; fileRef = F2D86E780F8EB57000B912A2 /* TestFiles */; };
+		F2D86E840F8EB76C00B912A2 /* SEPDocument.m in Sources */ = {isa = PBXBuildFile; fileRef = F2D86E830F8EB76C00B912A2 /* SEPDocument.m */; };
 		F2DCD8F20EE432F900F2854F /* FontForwardingTextField.m in Sources */ = {isa = PBXBuildFile; fileRef = F2DCD8F10EE432F900F2854F /* FontForwardingTextField.m */; };
+		F2DEC3130F8FA17A00ADEE48 /* FullTextStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = F281D34B0F38756100AD7DE1 /* FullTextStorage.m */; };
+		F2DEC3140F8FA17D00ADEE48 /* FoldableTextStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = F281D34C0F38756100AD7DE1 /* FoldableTextStorage.m */; };
+		F2DEC3360F8FA6DF00ADEE48 /* AbstractFoldingTextStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = F281D35F0F38758600AD7DE1 /* AbstractFoldingTextStorage.m */; };
+		F2DEC34A0F8FA71800ADEE48 /* FoldedTextAttachment.m in Sources */ = {isa = PBXBuildFile; fileRef = F281D3900F3877A900AD7DE1 /* FoldedTextAttachment.m */; };
+		F2DEC34F0F8FA72000ADEE48 /* FoldingTextAttachmentCell.m in Sources */ = {isa = PBXBuildFile; fileRef = F281D4360F388A0B00AD7DE1 /* FoldingTextAttachmentCell.m */; };
+		F2DEC8820F90005700ADEE48 /* NSStringSEEAdditions.m in Sources */ = {isa = PBXBuildFile; fileRef = 1428920B095751CB00D14688 /* NSStringSEEAdditions.m */; };
 		F2F2B5A70CA7F7B80045C189 /* PrecedencePreferences.m in Sources */ = {isa = PBXBuildFile; fileRef = 31D2C6E70CA7C7A7003CC5C9 /* PrecedencePreferences.m */; };
 		F2F2B60E0CA811240045C189 /* TCMMMLogStatisticsDataPoint.m in Sources */ = {isa = PBXBuildFile; fileRef = F2F2B60D0CA811240045C189 /* TCMMMLogStatisticsDataPoint.m */; };
 		F2F2B6100CA811240045C189 /* TCMMMLogStatisticsDataPoint.m in Sources */ = {isa = PBXBuildFile; fileRef = F2F2B60D0CA811240045C189 /* TCMMMLogStatisticsDataPoint.m */; };
@@ -679,6 +715,20 @@
 			remoteGlobalIDString = 8D57630D048677EA00EA77CD;
 			remoteInfo = SeeTextImporter;
 		};
+		F2D86C250F8E7EA800B912A2 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 14F16CEF0971A87300402129 /* OgreKit.xcodeproj */;
+			proxyType = 1;
+			remoteGlobalIDString = 4DC40BF209150BDB0029A2A6;
+			remoteInfo = "OgreKit (without Find Panel)";
+		};
+		F2D86C270F8E7EB100B912A2 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = F2A093B40C9EBB42000AD27A /* UniversalDetector.xcodeproj */;
+			proxyType = 1;
+			remoteGlobalIDString = 8DC2EF4F0486A6940098B216;
+			remoteInfo = UniversalDetector;
+		};
 /* End PBXContainerItemProxy section */
 
 /* Begin PBXCopyFilesBuildPhase section */
@@ -1352,6 +1402,20 @@
 		F2D5FF4C0CB2679100407399 /* PrintPrefs.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = PrintPrefs.icns; path = artwork/PrintPrefs.icns; sourceTree = "<group>"; };
 		F2D5FF4F0CB26EA800407399 /* ToolbarIconRunInTerminal.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = ToolbarIconRunInTerminal.icns; path = artwork/ToolbarIconRunInTerminal.icns; sourceTree = "<group>"; };
 		F2D5FF500CB26EA800407399 /* ToolbarIconTerminal.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = ToolbarIconTerminal.icns; path = artwork/ToolbarIconTerminal.icns; sourceTree = "<group>"; };
+		F2D86C1F0F8E7E2A00B912A2 /* SubEthaPerf.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = SubEthaPerf.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		F2D86C2C0F8E7EFA00B912A2 /* SEPAppController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SEPAppController.h; sourceTree = "<group>"; };
+		F2D86C2D0F8E7EFA00B912A2 /* SEPAppController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SEPAppController.m; sourceTree = "<group>"; };
+		F2D86C2F0F8E7F6A00B912A2 /* SEPMainMenu.xib */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = SEPMainMenu.xib; path = SubEthaPerf/Resources/SEPMainMenu.xib; sourceTree = "<group>"; };
+		F2D86C3B0F8E7FC300B912A2 /* SubEthaPerf-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = "SubEthaPerf-Info.plist"; path = "Resources/SubEthaPerf-Info.plist"; sourceTree = "<group>"; };
+		F2D86C500F8E811600B912A2 /* main.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
+		F2D86C7D0F8E849800B912A2 /* SEPLogger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SEPLogger.h; sourceTree = "<group>"; };
+		F2D86C7E0F8E849800B912A2 /* SEPLogger.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SEPLogger.m; sourceTree = "<group>"; };
+		F2D86CAC0F8E896800B912A2 /* SubEthaPerf_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SubEthaPerf_Prefix.pch; sourceTree = "<group>"; };
+		F2D86DB80F8E9B9A00B912A2 /* PreferenceKeys.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PreferenceKeys.h; sourceTree = "<group>"; };
+		F2D86DB90F8E9B9A00B912A2 /* PreferenceKeys.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PreferenceKeys.m; sourceTree = "<group>"; };
+		F2D86E780F8EB57000B912A2 /* TestFiles */ = {isa = PBXFileReference; lastKnownFileType = folder; name = TestFiles; path = SubEthaPerf/Resources/TestFiles; sourceTree = "<group>"; };
+		F2D86E820F8EB76C00B912A2 /* SEPDocument.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SEPDocument.h; sourceTree = "<group>"; };
+		F2D86E830F8EB76C00B912A2 /* SEPDocument.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SEPDocument.m; sourceTree = "<group>"; };
 		F2DCD8F00EE432F900F2854F /* FontForwardingTextField.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FontForwardingTextField.h; sourceTree = "<group>"; };
 		F2DCD8F10EE432F900F2854F /* FontForwardingTextField.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FontForwardingTextField.m; sourceTree = "<group>"; };
 		F2EFCBEF0CB656C700AEE298 /* German */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = German; path = German.lproj/ConnectionBrowser.nib; sourceTree = "<group>"; };
@@ -1421,6 +1485,16 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		F2D86C1D0F8E7E2A00B912A2 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				F2D86CDC0F8E8B2600B912A2 /* Carbon.framework in Frameworks */,
+				F2D86C3D0F8E7FFB00B912A2 /* UniversalDetector.framework in Frameworks */,
+				F2D86C3E0F8E801400B912A2 /* OgreKit.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
@@ -1914,6 +1988,8 @@
 				14289396095758C100D14688 /* OverlayView.m */,
 				14289397095758C100D14688 /* PrintPreferences.h */,
 				14289398095758C100D14688 /* PrintPreferences.m */,
+				F2D86DB80F8E9B9A00B912A2 /* PreferenceKeys.h */,
+				F2D86DB90F8E9B9A00B912A2 /* PreferenceKeys.m */,
 				31D2C6E60CA7C7A7003CC5C9 /* PrecedenceRuleCell.h */,
 				31D2C6E50CA7C7A7003CC5C9 /* PrecedenceRuleCell.m */,
 				31D2C6E80CA7C7A7003CC5C9 /* PrecedencePreferences.h */,
@@ -2070,6 +2146,7 @@
 				5EC6382A0ABEB71100D3295B /* Unit Tests.octest */,
 				14251B920BBD5DD300052C84 /* seed */,
 				F2B6CCC20EE9C6390077417E /* SeeTextImporter.mdimporter */,
+				F2D86C1F0F8E7E2A00B912A2 /* SubEthaPerf.app */,
 			);
 			name = Products;
 			sourceTree = "<group>";
@@ -2101,6 +2178,7 @@
 				142894DA095766D000D14688 /* see */,
 				2A37F4B8FDCFA73011CA2CEA /* Resources */,
 				2A37F4C3FDCFA73011CA2CEA /* Frameworks */,
+				F2D86C150F8E7DA200B912A2 /* SubEthaPerf */,
 				19C28FB0FE9D524F11CA2CBB /* Products */,
 				F2BB0A8A0CA043E200258EC7 /* HMBlkAppKit.xcodeproj */,
 				31D5F8510AA2FB760088DB18 /* CrashReporter.xcodeproj */,
@@ -2351,6 +2429,33 @@
 			name = Products;
 			sourceTree = "<group>";
 		};
+		F2D86C150F8E7DA200B912A2 /* SubEthaPerf */ = {
+			isa = PBXGroup;
+			children = (
+				F2D86CAC0F8E896800B912A2 /* SubEthaPerf_Prefix.pch */,
+				F2D86C5F0F8E817200B912A2 /* Resources */,
+				F2D86C500F8E811600B912A2 /* main.m */,
+				F2D86C2C0F8E7EFA00B912A2 /* SEPAppController.h */,
+				F2D86C2D0F8E7EFA00B912A2 /* SEPAppController.m */,
+				F2D86C3B0F8E7FC300B912A2 /* SubEthaPerf-Info.plist */,
+				F2D86C7D0F8E849800B912A2 /* SEPLogger.h */,
+				F2D86C7E0F8E849800B912A2 /* SEPLogger.m */,
+				F2D86E820F8EB76C00B912A2 /* SEPDocument.h */,
+				F2D86E830F8EB76C00B912A2 /* SEPDocument.m */,
+			);
+			path = SubEthaPerf;
+			sourceTree = "<group>";
+		};
+		F2D86C5F0F8E817200B912A2 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				F2D86E780F8EB57000B912A2 /* TestFiles */,
+				F2D86C2F0F8E7F6A00B912A2 /* SEPMainMenu.xib */,
+			);
+			name = Resources;
+			path = ..;
+			sourceTree = "<group>";
+		};
 /* End PBXGroup section */
 
 /* Begin PBXLegacyTarget section */
@@ -2475,6 +2580,26 @@
 			productReference = 8D15AC370486D014006FF6A4 /* SubEthaEdit.app */;
 			productType = "com.apple.product-type.application";
 		};
+		F2D86C1E0F8E7E2A00B912A2 /* SubEthaPerf */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = F2D86C240F8E7E2B00B912A2 /* Build configuration list for PBXNativeTarget "SubEthaPerf" */;
+			buildPhases = (
+				F2D86C1B0F8E7E2A00B912A2 /* Resources */,
+				F2D86C1C0F8E7E2A00B912A2 /* Sources */,
+				F2D86C1D0F8E7E2A00B912A2 /* Frameworks */,
+				F2D86C670F8E820C00B912A2 /* ShellScript */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				F2D86C260F8E7EA800B912A2 /* PBXTargetDependency */,
+				F2D86C280F8E7EB100B912A2 /* PBXTargetDependency */,
+			);
+			name = SubEthaPerf;
+			productName = SubEthaPerf;
+			productReference = F2D86C1F0F8E7E2A00B912A2 /* SubEthaPerf.app */;
+			productType = "com.apple.product-type.application";
+		};
 /* End PBXNativeTarget section */
 
 /* Begin PBXProject section */
@@ -2530,6 +2655,7 @@
 				142898180958189300D14688 /* Create Disk Image */,
 				5EC638290ABEB71100D3295B /* Unit Tests */,
 				14C431AB0BF34655007D29EB /* World */,
+				F2D86C1E0F8E7E2A00B912A2 /* SubEthaPerf */,
 			);
 		};
 /* End PBXProject section */
@@ -2841,6 +2967,16 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		F2D86C1B0F8E7E2A00B912A2 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				F2D86C300F8E7F6A00B912A2 /* SEPMainMenu.xib in Resources */,
+				F2D86E5B0F8EB44100B912A2 /* Modes in Resources */,
+				F2D86E7B0F8EB57000B912A2 /* TestFiles in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXResourcesBuildPhase section */
 
 /* Begin PBXRezBuildPhase section */
@@ -2945,6 +3081,19 @@
 			shellPath = /bin/sh;
 			shellScript = "export PATH=$PATH:/usr/local/bin\nREVISION=`/usr/bin/env svnversion \"$SRCROOT\"`\ncpp -P -DREVISION=$REVISION $INFOPLIST_FILE $SCRIPT_OUTPUT_FILE_0\nexit 0";
 		};
+		F2D86C670F8E820C00B912A2 /* ShellScript */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = "/usr/bin/perl -w";
+			shellScript = "# Xcode auto-versioning script for Subversion\n# by Axel Andersson, modified by Daniel Jalkut to add\n# \"--revision HEAD\" to the svn info line, which allows\n# the latest revision to always be used.\n        \nuse strict;\n        \ndie \"$0: Must be run from Xcode\" unless $ENV{\"BUILT_PRODUCTS_DIR\"};\n        \n# Get the current subversion revision number and use it to set the CFBundleVersion value\nmy $REV = `export PATH=\\$PATH:/usr/local/bin;/usr/bin/env svnversion -n ./`;\nmy $INFO = \"$ENV{BUILT_PRODUCTS_DIR}/$ENV{WRAPPER_NAME}/Contents/Info.plist\";\n        \nmy $version = $REV;\n$version =~ s/([\\d]*:)(\\d+[M|S]*).*/$2/;\ndie \"$0: No Subversion revision found\" unless $version;\n        \nopen(FH, \"$INFO\") or die \"$0: $INFO: $!\";\nmy $info = join(\"\", <FH>);\nclose(FH);\n        \n$info =~ s/([\\t ]+<key>CFBundleVersion<\\/key>\\n[\\t ]+<string>).*?(<\\/string>)/$1$version$2/;\n        \nopen(FH, \">$INFO\") or die \"$0: $INFO: $!\";\nprint FH $info;\nclose(FH);\n";
+		};
 /* End PBXShellScriptBuildPhase section */
 
 /* Begin PBXSourcesBuildPhase section */
@@ -3214,9 +3363,46 @@
 				F281D3910F3877A900AD7DE1 /* FoldedTextAttachment.m in Sources */,
 				F281D4370F388A0B00AD7DE1 /* FoldingTextAttachmentCell.m in Sources */,
 				F20396F60F8A707700BEB377 /* FullTextStorage.m in Sources */,
+				F2D86E1B0F8EA5DC00B912A2 /* PreferenceKeys.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		F2D86C1C0F8E7E2A00B912A2 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				F2D86C2E0F8E7EFA00B912A2 /* SEPAppController.m in Sources */,
+				F2D86C510F8E811600B912A2 /* main.m in Sources */,
+				F2D86C7F0F8E849800B912A2 /* SEPLogger.m in Sources */,
+				F2D86C9F0F8E88EB00B912A2 /* SyntaxStyle.m in Sources */,
+				F2D86CA00F8E88EC00B912A2 /* SyntaxHighlighter.m in Sources */,
+				F2D86CA10F8E88ED00B912A2 /* SyntaxDefinition.m in Sources */,
+				F2D86CB90F8E8A0F00B912A2 /* DocumentModeManager.m in Sources */,
+				F2D86CBA0F8E8A1400B912A2 /* DocumentMode.m in Sources */,
+				F2D86CBF0F8E8A2E00B912A2 /* ScriptWrapper.m in Sources */,
+				F2D86CC30F8E8A5200B912A2 /* EncodingManager.m in Sources */,
+				F2D86CC60F8E8A5B00B912A2 /* RegexSymbolParser.m in Sources */,
+				F2D86CC70F8E8A5C00B912A2 /* RegexSymbolDefinition.m in Sources */,
+				F2D86CCF0F8E8A7A00B912A2 /* SymbolTableEntry.m in Sources */,
+				F2D86CD40F8E8ABD00B912A2 /* NSColorTCMAdditions.m in Sources */,
+				F2D86DA40F8E8B3E00B912A2 /* ModeSettings.m in Sources */,
+				F2D86DAA0F8E8B6000B912A2 /* SelectionOperation.m in Sources */,
+				F2D86DAD0F8E8B6600B912A2 /* TextOperation.m in Sources */,
+				F2D86DB20F8E8B7F00B912A2 /* TCMMMOperation.m in Sources */,
+				F2D86DBA0F8E9B9A00B912A2 /* PreferenceKeys.m in Sources */,
+				F2D86DDD0F8E9CF500B912A2 /* CFTreeTCMAdditions.m in Sources */,
+				F2D86E840F8EB76C00B912A2 /* SEPDocument.m in Sources */,
+				F212908B0F8EC56F0076B6B1 /* NSDictionaryTCMAdditions.m in Sources */,
+				F21290980F8EC5870076B6B1 /* NSMutableAttributedStringSEEAdditions.m in Sources */,
+				F2DEC3130F8FA17A00ADEE48 /* FullTextStorage.m in Sources */,
+				F2DEC3140F8FA17D00ADEE48 /* FoldableTextStorage.m in Sources */,
+				F2DEC3360F8FA6DF00ADEE48 /* AbstractFoldingTextStorage.m in Sources */,
+				F2DEC34A0F8FA71800ADEE48 /* FoldedTextAttachment.m in Sources */,
+				F2DEC34F0F8FA72000ADEE48 /* FoldingTextAttachmentCell.m in Sources */,
+				F2DEC8820F90005700ADEE48 /* NSStringSEEAdditions.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXSourcesBuildPhase section */
 
 /* Begin PBXTargetDependency section */
@@ -3280,6 +3466,16 @@
 			name = SeeTextImporter;
 			targetProxy = F2D22CB50EE9C5ED004B8E33 /* PBXContainerItemProxy */;
 		};
+		F2D86C260F8E7EA800B912A2 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = "OgreKit (without Find Panel)";
+			targetProxy = F2D86C250F8E7EA800B912A2 /* PBXContainerItemProxy */;
+		};
+		F2D86C280F8E7EB100B912A2 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = UniversalDetector;
+			targetProxy = F2D86C270F8E7EB100B912A2 /* PBXContainerItemProxy */;
+		};
 /* End PBXTargetDependency section */
 
 /* Begin PBXVariantGroup section */
@@ -3853,6 +4049,7 @@
 				INFOPLIST_OTHER_PREPROCESSOR_FLAGS = "-C";
 				INFOPLIST_PREPROCESS = YES;
 				INSTALL_PATH = "$(HOME)/Applications";
+				OTHER_CFLAGS = "-DSUBETHAEDIT";
 				OTHER_LDFLAGS = (
 					"-lz",
 					"-framework",
@@ -3886,6 +4083,12 @@
 				INFOPLIST_OTHER_PREPROCESSOR_FLAGS = "-C";
 				INFOPLIST_PREPROCESS = YES;
 				INSTALL_PATH = /;
+				OTHER_CFLAGS = (
+					"-DTCM_NO_DEBUG",
+					"-DNS_BLOCK_ASSERTIONS",
+					"-DNDEBUG",
+					"-DSUBETHAEDIT",
+				);
 				OTHER_LDFLAGS = (
 					"-lz",
 					"-framework",
@@ -3936,6 +4139,58 @@
 			};
 			name = Release;
 		};
+		F2D86C220F8E7E2B00B912A2 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = SubEthaPerf/SubEthaPerf_Prefix.pch;
+				INFOPLIST_FILE = "SubEthaPerf/Resources/SubEthaPerf-Info.plist";
+				INSTALL_PATH = "$(HOME)/Applications";
+				MACOSX_DEPLOYMENT_TARGET = 10.5;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Foundation,
+					"-framework",
+					AppKit,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = SubEthaPerf;
+				SDKROOT = macosx10.5;
+			};
+			name = Debug;
+		};
+		F2D86C230F8E7E2B00B912A2 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = SubEthaPerf/SubEthaPerf_Prefix.pch;
+				INFOPLIST_FILE = "SubEthaPerf/Resources/SubEthaPerf-Info.plist";
+				INSTALL_PATH = "$(HOME)/Applications";
+				MACOSX_DEPLOYMENT_TARGET = 10.5;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Foundation,
+					"-framework",
+					AppKit,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = SubEthaPerf;
+				SDKROOT = macosx10.5;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
 /* End XCBuildConfiguration section */
 
 /* Begin XCConfigurationList section */
@@ -4011,6 +4266,15 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
+		F2D86C240F8E7E2B00B912A2 /* Build configuration list for PBXNativeTarget "SubEthaPerf" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				F2D86C220F8E7E2B00B912A2 /* Debug */,
+				F2D86C230F8E7E2B00B912A2 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
 /* End XCConfigurationList section */
 	};
 	rootObject = 2A37F4A9FDCFA73011CA2CEA /* Project object */;
Index: SubEthaPerf/main.m
===================================================================
--- SubEthaPerf/main.m	(revision 0)
+++ SubEthaPerf/main.m	(revision 2981)
@@ -0,0 +1,12 @@
+//
+//  main.m
+//
+//  Copyright (c) 2007-2008 TheCodingMonkeys: <http://codingmonkeys.de>
+//
+
+#import <Cocoa/Cocoa.h>
+
+int main(int argc, char *argv[])
+{
+    return NSApplicationMain(argc,  (const char **) argv);
+}
Index: SubEthaPerf/SEPDocument.m
===================================================================
--- SubEthaPerf/SEPDocument.m	(revision 0)
+++ SubEthaPerf/SEPDocument.m	(revision 2981)
@@ -0,0 +1,175 @@
+//
+//  SEPDocument.m
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import "SEPDocument.h"
+#import "SEPLogger.h"
+#import "SyntaxHighlighter.h"
+#import "DocumentModeManager.h"
+#import "PreferenceKeys.h"
+#import "FoldableTextStorage.h"
+#import "FullTextStorage.h"
+
+
+@implementation SEPDocument
+
+@synthesize textStorage;
+
+- (id)initWithURL:(NSURL *)inURL
+{
+	if ((self = [super init])) {
+		NSDictionary *documentAttributes = nil;
+		NSError *error = nil;
+		self.textStorage = [NSTextStorage new];
+		if ([textStorage readFromURL:inURL options:[NSDictionary dictionaryWithObjectsAndKeys:NSPlainTextDocumentType,@"DocumentType",nil] documentAttributes:&documentAttributes error:&error]) {
+			[self setPlainFont:[NSFont systemFontOfSize:12]];
+//			[SEPLogger logWithFormat:@"%s Attributes:%@", __FUNCTION__, documentAttributes];
+			I_documentMode = [[DocumentModeManager sharedInstance] documentModeForPath:[inURL path] withContentString:[textStorage string]];
+		} else {
+			[SEPLogger logWithFormat:@"%s loading failed with error:%@", __FUNCTION__, error];
+			self.textStorage = nil;
+			[super dealloc];
+			return nil;
+		}
+	}
+	
+	return self;
+}
+
+
+- (void)changeToFoldableTextStorage {
+	id foldableTextStorage = [FoldableTextStorage new];
+	[[foldableTextStorage mutableString] setString:[textStorage string]];
+	self.textStorage = foldableTextStorage;
+}
+
+- (void)addOneFolding {
+	// just fold the last character to create the second textstorage
+	[textStorage foldRange:NSMakeRange([textStorage length]-1,1)];
+}
+
+
+- (void)foldEveryOtherLine {
+	NSString *string = [textStorage string];
+	NSRange lineRange = NSMakeRange([string length]-1,1);
+	
+	int counter = 0;
+	while (lineRange.location > 0) {
+		lineRange = [string lineRangeForRange:NSMakeRange(lineRange.location-1,1)];
+		counter++;
+		if (counter % 2) {
+			[textStorage foldRange:lineRange];
+		}
+	}
+}
+
+- (NSTimeInterval)timedHighlightAll {
+	SyntaxHighlighter *syntaxHighlighter = [I_documentMode syntaxHighlighter];
+	
+	id textStorageToHighlight = textStorage;
+	if ([textStorageToHighlight isKindOfClass:[FoldableTextStorage class]]) {
+		textStorageToHighlight = [textStorageToHighlight fullTextStorage];
+	}
+	
+	[textStorageToHighlight removeAttribute:kSyntaxHighlightingIsCorrectAttributeName range:NSMakeRange(0,[textStorageToHighlight length])];
+	START_TIMING(highlighting);
+	int numberOfRuns = 1;
+	while (![syntaxHighlighter colorizeDirtyRanges:textStorageToHighlight ofDocument:self]) {
+		numberOfRuns++;
+	}
+	NSTimeInterval result = END_TIMING(highlighting);
+	NSLog(@"%s %d number of calls into the highlighter",__FUNCTION__,numberOfRuns);
+	return result;
+}
+
+- (DocumentMode *)documentMode {
+	return I_documentMode;
+}
+
+- (void)dealloc {
+	[textStorage release];
+	[super dealloc];
+}
+
+- (void)TCM_styleFonts {
+    [I_fonts.boldFont autorelease];
+    [I_fonts.italicFont autorelease];
+    [I_fonts.boldItalicFont autorelease];
+    NSFontManager *manager=[NSFontManager sharedFontManager];
+    I_fonts.boldFont       = [[manager convertFont:I_fonts.plainFont toHaveTrait:NSBoldFontMask] retain];
+    I_fonts.italicFont     = [[manager convertFont:I_fonts.plainFont toHaveTrait:NSItalicFontMask] retain];
+    I_fonts.boldItalicFont = [[manager convertFont:I_fonts.boldFont  toHaveTrait:NSItalicFontMask] retain];
+}
+
+- (void)setPlainFont:(NSFont *)aFont {
+    [I_styleCacheDictionary autorelease];
+    I_styleCacheDictionary = [NSMutableDictionary new];
+    BOOL useDefaultStyle=[[[self documentMode] defaultForKey:DocumentModeUseDefaultStylePreferenceKey] boolValue];
+    BOOL darkBackground=[[[self documentMode] defaultForKey:DocumentModeBackgroundColorIsDarkPreferenceKey] boolValue];
+    NSDictionary *syntaxStyle=[useDefaultStyle?[[DocumentModeManager baseMode] syntaxStyle]:[[self documentMode] syntaxStyle] styleForKey:SyntaxStyleBaseIdentifier];
+//    [self setDocumentBackgroundColor:[syntaxStyle objectForKey:darkBackground?@"inverted-background-color":@"background-color"]];
+//    [self setDocumentForegroundColor:[syntaxStyle objectForKey:darkBackground?@"inverted-color":@"color"]];
+    [I_fonts.plainFont autorelease];
+    I_fonts.plainFont = [aFont copy];
+    [self TCM_styleFonts];
+}
+
+
+/*"A font trait mask of 0 returns the plain font, otherwise use NSBoldFontMask, NSItalicFontMask"*/
+- (NSFont *)fontWithTrait:(NSFontTraitMask)aFontTrait {
+    if ((aFontTrait & NSBoldFontMask) && (aFontTrait & NSItalicFontMask)) {
+        return I_fonts.boldItalicFont;
+    } else if (aFontTrait & NSItalicFontMask) {
+        return I_fonts.italicFont;
+    } else if (aFontTrait & NSBoldFontMask) {
+        return I_fonts.boldFont;
+    } else {
+        return I_fonts.plainFont;
+    }
+}
+
+- (NSDictionary *)styleAttributesForStyleID:(NSString *)aStyleID {
+	if (!aStyleID) {
+		NSLog(@"%s was called with a styleID of nil",__FUNCTION__);
+		return [NSDictionary dictionary];
+	}
+    NSDictionary *result=[I_styleCacheDictionary objectForKey:aStyleID];
+    if (!result) {
+        DocumentMode *documentMode=I_documentMode;
+        BOOL darkBackground=[[documentMode defaultForKey:DocumentModeBackgroundColorIsDarkPreferenceKey] boolValue];
+        NSDictionary *style=nil;
+        if ([aStyleID isEqualToString:SyntaxStyleBaseIdentifier] && 
+            [[documentMode defaultForKey:DocumentModeUseDefaultStylePreferenceKey] boolValue]) {
+            style=[[[DocumentModeManager baseMode] syntaxStyle] styleForKey:aStyleID];
+        } else {
+            style=[[documentMode syntaxStyle] styleForKey:aStyleID];
+        }
+        NSFontTraitMask traits=[[style objectForKey:@"font-trait"] unsignedIntValue];
+        NSFont *font=[self fontWithTrait:traits];
+        BOOL synthesise=[[NSUserDefaults standardUserDefaults] boolForKey:SynthesiseFontsPreferenceKey];
+        float obliquenessFactor=0.;
+        if (synthesise && (traits & NSItalicFontMask) && !([[NSFontManager sharedFontManager] traitsOfFont:font] & NSItalicFontMask)) {
+            obliquenessFactor=.2;
+        }
+        float strokeWidth=.0;
+        if (synthesise && (traits & NSBoldFontMask) && !([[NSFontManager sharedFontManager] traitsOfFont:font] & NSBoldFontMask)) {
+            strokeWidth=darkBackground?-9.:-3.;
+        }
+        NSColor *foregroundColor=[style objectForKey:darkBackground?@"inverted-color":@"color"];
+        result=[NSDictionary dictionaryWithObjectsAndKeys:font,NSFontAttributeName,
+            foregroundColor,NSForegroundColorAttributeName,
+            aStyleID,@"styleID",
+            [NSNumber numberWithFloat:obliquenessFactor],NSObliquenessAttributeName,
+            [NSNumber numberWithFloat:strokeWidth],NSStrokeWidthAttributeName,
+            nil];
+        [I_styleCacheDictionary setObject:result forKey:aStyleID];
+    }
+    return result;
+}
+
+
+@end
Index: SubEthaPerf/SEPAppController.h
===================================================================
--- SubEthaPerf/SEPAppController.h	(revision 0)
+++ SubEthaPerf/SEPAppController.h	(revision 2981)
@@ -0,0 +1,32 @@
+//
+//  SEPAppController.h
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+
+
+@interface SEPAppController : NSObject {
+	IBOutlet NSTextView *ibResultsTextView;
+	IBOutlet NSProgressIndicator *ibProgressIndicator;
+
+	BOOL testNSTextStorage;
+	BOOL testFoldableTextStorage;
+	BOOL testFoldableTextStorageOneFolding;
+	BOOL testFoldableTextStorageEveryOtherLineFolding;
+	int numberOfRepeats;
+	NSFileHandle *logFileHandle;
+}
+
+@property int numberOfRepeats;
+@property BOOL testNSTextStorage;
+@property BOOL testFoldableTextStorage;
+@property BOOL testFoldableTextStorageOneFolding;
+@property BOOL testFoldableTextStorageEveryOtherLineFolding;
+
+- (IBAction)runTests:(id)aSender;
+
+@end
Index: SubEthaPerf/SEPLogger.m
===================================================================
--- SubEthaPerf/SEPLogger.m	(revision 0)
+++ SubEthaPerf/SEPLogger.m	(revision 2981)
@@ -0,0 +1,43 @@
+//
+//  SEPLogger.m
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import "SEPLogger.h"
+
+static NSMutableArray *loggingArray;
+
+@implementation SEPLogger
++ (void)initialize {
+	if (self == [SEPLogger class]) {
+		loggingArray = [NSMutableArray new];
+	}
+}
+
++ (void)logWithFormat:(NSString *)format,... {
+	va_list va;
+	va_start(va,format);
+	NSString *string = [[NSString alloc] initWithFormat:format arguments:va];
+	va_end(va);
+	[loggingArray makeObjectsPerformSelector:@selector(logString:) withObject:string];
+	[string release];
+}
+
++ (void)registerLogger:(id)aLogger {
+	[loggingArray addObject:aLogger];
+}
+@end
+
+@implementation NSString (SEPLoggerStringAdditions)
+- (NSString *)stringByLeftPaddingUpToLength:(int)aLength {
+	NSString *result = self;
+	int lengthDifference = aLength - [self length];
+	if (lengthDifference > 0) {
+		result = [[@"" stringByPaddingToLength:lengthDifference withString:@" " startingAtIndex:0] stringByAppendingString:self];
+	}
+	return result;
+}
+@end
\ No newline at end of file
Index: SubEthaPerf/SEPAppController.m
===================================================================
--- SubEthaPerf/SEPAppController.m	(revision 0)
+++ SubEthaPerf/SEPAppController.m	(revision 2981)
@@ -0,0 +1,165 @@
+//
+//  SEPAppController.m
+//  SubEthaEdit
+//
+//  Created by Dominik Wagner on 09.04.09.
+//  Copyright 2009 TheCodingMonkeys. All rights reserved.
+//
+
+#import "SEPLogger.h"
+#import "SEPAppController.h"
+#import "SEPDocument.h"
+
+
+@implementation SEPAppController
+
+@synthesize testNSTextStorage,testFoldableTextStorage, testFoldableTextStorageOneFolding, testFoldableTextStorageEveryOtherLineFolding, numberOfRepeats;
+
+- (void)setupLogFile {
+	NSString *appName = [[[[NSBundle mainBundle] bundlePath] lastPathComponent] stringByDeletingPathExtension];
+	NSString *appDir = [[@"~/Library/Logs/" stringByExpandingTildeInPath] stringByAppendingPathComponent:appName];
+	[[NSFileManager defaultManager] createDirectoryAtPath:appDir attributes:nil];
+	
+    int sequenceNumber = 0;
+	NSString *name;
+	do {
+		sequenceNumber++;
+		name = [NSString stringWithFormat:@"Perflog-%@-%@-%d.log", [[NSCalendarDate date] descriptionWithCalendarFormat:@"%Y-%m-%d--%H-%M"], [[NSProcessInfo processInfo] hostName], sequenceNumber];
+		name = [appDir stringByAppendingPathComponent:name];
+	} while ([[NSFileManager defaultManager] fileExistsAtPath:name]);
+
+    [[NSFileManager defaultManager] createFileAtPath:name contents:[NSData data] attributes:nil];
+    logFileHandle = [[NSFileHandle fileHandleForWritingAtPath:name] retain];
+}
+
+- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
+	[self setupLogFile];
+
+	[SEPLogger registerLogger:self];
+	[SEPLogger logWithFormat:@"------ start up (v%@)-----\n", [[[NSBundle mainBundle] infoDictionary] valueForKey:@"CFBundleVersion"]];
+	NSProcessInfo *info = [NSProcessInfo processInfo];
+	[SEPLogger logWithFormat:@"%@, %d cpus, %d MB, %@\n",[info hostName],[info activeProcessorCount],[info physicalMemory] / 1024 / 1024,[info operatingSystemVersionString]];
+	self.testNSTextStorage 								= YES;
+	self.testFoldableTextStorage						= NO;
+	self.testFoldableTextStorageOneFolding				= NO;
+	self.testFoldableTextStorageEveryOtherLineFolding	= NO;
+	self.numberOfRepeats = 3;
+	
+	
+	if ([[NSUserDefaults standardUserDefaults] boolForKey:@"RunTestsAtStart"]) {
+		[self performSelector:@selector(runTests:) withObject:nil afterDelay:2];
+	}
+}
+
+
+- (void)applicationWillTerminate:(NSNotification *)aNotification {
+	[logFileHandle closeFile];
+	[logFileHandle release];
+}
+
+- (void)reportTimingArray:(NSArray *)anArray forByteLength:(double)byteLength {
+	double average = [[anArray valueForKeyPath:@"@avg.self"] doubleValue];
+	double variance = 0.0;
+	for (NSNumber *value in anArray) {
+		variance += pow([value doubleValue] - average,2);
+//		[SEPLogger logWithFormat:@"| %03.3f ",[value doubleValue]];
+	}
+	variance = variance / [anArray count];
+	double deviance = sqrt(variance);
+	double ninetyFivePercentConfidenceInterval = (deviance * 2) / average * 100.0;
+	
+	[SEPLogger logWithFormat:@"||%@ |%@ | +/-%@ ",
+		[[NSString stringWithFormat:@"%03.3fs",average] stringByLeftPaddingUpToLength:8],
+		[[NSString stringWithFormat:@"%03.1fkb/s",byteLength / 1024.0 / average] stringByLeftPaddingUpToLength:12],
+		[[NSString stringWithFormat:@"%.1f %%",ninetyFivePercentConfidenceInterval] stringByLeftPaddingUpToLength:8]];
+		
+}
+
+- (void)testFileAtPath:(NSString *)aFilePath
+{
+	NSMutableArray *timingArray = [NSMutableArray new];
+	NSString *fileName = [aFilePath lastPathComponent];
+	int byteSize = [[[NSFileManager defaultManager] fileAttributesAtPath:aFilePath traverseLink:YES] fileSize];
+	
+	int testMode=0;
+	for (testMode=0; testMode<4; testMode++) {
+		[timingArray removeAllObjects];
+		if ((testMode == 0 && !self.testNSTextStorage) ||
+			(testMode == 1 && !self.testFoldableTextStorage) ||
+			(testMode == 2 && !self.testFoldableTextStorageOneFolding) ||
+			(testMode == 3 && !self.testFoldableTextStorageEveryOtherLineFolding)) {
+			continue;
+		}
+		NSString *textStorageType = @"NSTextStorage";
+		switch (testMode) {
+			case 1: textStorageType = @"Foldable"; break;
+			case 2: textStorageType = @"Foldable1Fold"; break;
+			case 3: textStorageType = @"FoldableManyFold"; break;
+		}
+		[SEPLogger logWithFormat:
+			[[NSString stringWithFormat:@"-> %@ (%d kb)", fileName, byteSize / 1024]
+				stringByPaddingToLength:40 withString:@" " startingAtIndex:0]];
+		[SEPLogger logWithFormat:
+			[[NSString stringWithFormat:@"%@ ",textStorageType]
+				stringByPaddingToLength:17 withString:@" " startingAtIndex:0]];
+		[ibResultsTextView display];
+	
+		int i = 0;
+		for (;i<self.numberOfRepeats;i++) {
+			SEPDocument *document = [[SEPDocument alloc] initWithURL:[NSURL fileURLWithPath:aFilePath]];
+			if (document) {
+				if (testMode > 0) {
+					[document changeToFoldableTextStorage];
+					if (testMode == 2) {
+						[document addOneFolding];
+					} else if (testMode == 3) {
+						[document foldEveryOtherLine];
+					}
+				}
+				NSTimeInterval time = [document timedHighlightAll];
+				[timingArray addObject:[NSNumber numberWithFloat:time]];
+				[document release];
+			}
+		}
+		[self reportTimingArray:timingArray forByteLength:byteSize];
+		[SEPLogger logWithFormat:@"\n"];
+		[ibResultsTextView display];
+	}
+	
+	[timingArray release];
+}
+
+- (void)testFilesAtPath:(NSString *)aFilePath {
+	NSFileManager *fm = [NSFileManager defaultManager];
+	for (NSString *fileName in [[fm directoryContentsAtPath:aFilePath] sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]) {
+		NSString *filePath = [aFilePath stringByAppendingPathComponent:fileName];
+			[self testFileAtPath:filePath];
+	}
+	
+}
+
+- (void)application:(NSApplication *)anApplication openFiles:(NSArray *)aFilePathArray {
+	[SEPLogger logWithFormat:@"------ opening testfiles (%d times per document) -----\n", self.numberOfRepeats];
+	[anApplication replyToOpenOrPrint:NSApplicationDelegateReplySuccess]; // so finder isn't worried anymore
+	for (NSString *filePath in [aFilePathArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]) {
+		[self testFileAtPath:filePath];
+	}
+}
+
+- (IBAction)runTests:(id)aSender {
+	[ibProgressIndicator startAnimation:self];
+	[SEPLogger logWithFormat:@"------ runTests (%d times per document) -----\n", self.numberOfRepeats];
+	// load up all files in TestFiles
+	NSString *testfilePath = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"TestFiles"];
+	[self testFilesAtPath:testfilePath];
+	[ibProgressIndicator stopAnimation:self];
+}
+
+
+- (void)logString:(NSString *)aString
+{
+	[[[ibResultsTextView textStorage] mutableString] appendString:aString];
+	NSLog(@"%@",aString);
+	[logFileHandle writeData:[aString dataUsingEncoding:NSUTF8StringEncoding]];
+}
+@end


